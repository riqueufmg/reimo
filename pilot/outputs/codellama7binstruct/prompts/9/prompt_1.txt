You are an expert in refactoring code snippets. Here are some examples of refactoring using the Extract Method technique.

================= EXAMPLES =================

Example 1:

Refactoring Description: Extract Method public getTimestampedSnapshotName(clientSuppliedName String) : String extracted from public snapshot(clientSuppliedName String) : void in class org.apache.cassandra.db.Table

Code Before:
------------
@@ -152,20 +152,30 @@ public void forceCleanup()
      * @param clientSuppliedName the tag associated with the name of the snapshot.  This
      *                           value can be null.
      */
-    public void snapshot(String clientSuppliedName) throws IOException
     {
-        String snapshotName = Long.toString(System.currentTimeMillis());
-        if (clientSuppliedName != null && !clientSuppliedName.equals(""))
-        {
-            snapshotName = snapshotName + "-" + clientSuppliedName;
-        }
 
         for (ColumnFamilyStore cfStore : columnFamilyStores.values())
         {
             cfStore.snapshot(snapshotName);
         }
     }
 
 
     /**
      * Clear all the snapshots for a given table.

Code After:
------------
@@ -152,20 +152,30 @@ public void forceCleanup()
      * @param clientSuppliedName the tag associated with the name of the snapshot.  This
      *                           value can be null.
      */
+    public void snapshot(String clientSuppliedName)
     {
+        String snapshotName = getTimestampedSnapshotName(clientSuppliedName);
 
         for (ColumnFamilyStore cfStore : columnFamilyStores.values())
         {
             cfStore.snapshot(snapshotName);
         }
     }
 
+    /**
+     * @param clientSuppliedName; may be null.
+     * @return
+     */
+    public static String getTimestampedSnapshotName(String clientSuppliedName)
+    {
+        String snapshotName = Long.toString(System.currentTimeMillis());
+        if (clientSuppliedName != null && !clientSuppliedName.equals(""))
+        {
+            snapshotName = snapshotName + "-" + clientSuppliedName;
+        }
+        return snapshotName;
+    }
+
 
     /**
      * Clear all the snapshots for a given table.

Example 2:

Refactoring Description: Extract Method private getPropertyName(optionName String) : String extracted from package get(optionName String) : String in class com.oracle.truffle.polyglot.ImageBuildTimeOptions

Code Before:
------------
@@ -54,16 +54,24 @@ final class ImageBuildTimeOptions {
     static final OptionKey<String> PreinitializeContexts = new OptionKey<>(null, OptionType.defaultType(String.class));
 
     static final String PREINITIALIZE_CONTEXTS_WITH_NATIVE_NAME = "PreinitializeContextsWithNative";
-    @Option(name = PREINITIALIZE_CONTEXTS_WITH_NATIVE_NAME, category = OptionCategory.EXPERT, help = "Pre-initialize language contexts for the given languages, allowing native access.")//
-    static final OptionKey<String> PreinitializeContextsWithNative = new OptionKey<>(null, OptionType.defaultType(String.class));
 
     static final String DISABLE_PRIVILEGES_NAME = "DisablePrivileges";
     @Option(name = DISABLE_PRIVILEGES_NAME, category = OptionCategory.EXPERT, help = "Disable Context privileges so the related code can be excluded from the image.")//
     static final OptionKey<String> DisablePrivileges = new OptionKey<>("");
 
     static String get(String optionName) {
-        String property = OptionValuesImpl.SYSTEM_PROPERTY_PREFIX + PolyglotEngineImpl.OPTION_GROUP_IMAGE_BUILD_TIME + "." + optionName;
         return System.getProperty(property, "");
     }
 
 }

Code After:
------------
@@ -54,16 +54,24 @@ final class ImageBuildTimeOptions {
     static final OptionKey<String> PreinitializeContexts = new OptionKey<>(null, OptionType.defaultType(String.class));
 
     static final String PREINITIALIZE_CONTEXTS_WITH_NATIVE_NAME = "PreinitializeContextsWithNative";
+    @Option(name = PREINITIALIZE_CONTEXTS_WITH_NATIVE_NAME, category = OptionCategory.EXPERT, help = "Pre-initialize language contexts with native access privileges.")//
+    static final OptionKey<Boolean> PreinitializeContextsWithNative = new OptionKey<>(false);
 
     static final String DISABLE_PRIVILEGES_NAME = "DisablePrivileges";
     @Option(name = DISABLE_PRIVILEGES_NAME, category = OptionCategory.EXPERT, help = "Disable Context privileges so the related code can be excluded from the image.")//
     static final OptionKey<String> DisablePrivileges = new OptionKey<>("");
 
     static String get(String optionName) {
+        String property = getPropertyName(optionName);
         return System.getProperty(property, "");
     }
 
+    static Boolean getBoolean(String optionName) {
+        String property = getPropertyName(optionName);
+        return Boolean.getBoolean(property);
+    }
+
+    private static String getPropertyName(String optionName) {
+        return OptionValuesImpl.SYSTEM_PROPERTY_PREFIX + PolyglotEngineImpl.OPTION_GROUP_IMAGE_BUILD_TIME + "." + optionName;
+    }
 }

Example 3:

Refactoring Description: Extract Method private prefix(adr AMD64Address, reg Register, byteinst boolean) : void extracted from private prefix(adr AMD64Address, reg Register) : void in class com.oracle.graal.asm.amd64.AMD64Assembler

Code Before:
------------
@@ -917,7 +917,7 @@ public final void movb(AMD64Address dst, int imm8) {
 
     public final void movb(AMD64Address dst, Register src) {
         assert src.getRegisterCategory() == AMD64.CPU : "must have byte register";
-        prefix(dst, src); // , true)
         emitByte(0x88);
         emitOperandHelper(src, dst);
     }
@@ -1895,6 +1895,10 @@ private void prefixq(AMD64Address adr) {
     }
 
     private void prefix(AMD64Address adr, Register reg) {
         if (reg.encoding < 8) {
             if (needsRex(adr.getBase())) {
                 if (needsRex(adr.getIndex())) {
@@ -1905,7 +1909,7 @@ private void prefix(AMD64Address adr, Register reg) {
             } else {
                 if (needsRex(adr.getIndex())) {
                     emitByte(Prefix.REXX);
-                } else if (reg.encoding >= 4) {
                     emitByte(Prefix.REX);
                 }
             }

Code After:
------------
@@ -917,7 +917,7 @@ public final void movb(AMD64Address dst, int imm8) {
 
     public final void movb(AMD64Address dst, Register src) {
         assert src.getRegisterCategory() == AMD64.CPU : "must have byte register";
+        prefix(dst, src, true);
         emitByte(0x88);
         emitOperandHelper(src, dst);
     }
@@ -1895,6 +1895,10 @@ private void prefixq(AMD64Address adr) {
     }
 
     private void prefix(AMD64Address adr, Register reg) {
+        prefix(adr, reg, false);
+    }
+
+    private void prefix(AMD64Address adr, Register reg, boolean byteinst) {
         if (reg.encoding < 8) {
             if (needsRex(adr.getBase())) {
                 if (needsRex(adr.getIndex())) {
@@ -1905,7 +1909,7 @@ private void prefix(AMD64Address adr, Register reg) {
             } else {
                 if (needsRex(adr.getIndex())) {
                     emitByte(Prefix.REXX);
+                } else if (byteinst && reg.encoding >= 4) {
                     emitByte(Prefix.REX);
                 }
             }

================= REFACTORING MECHANICS =================

Please provide a refactored version of the code snippets above using the Extract Method technique, following these mechanics: 

1. Find a piece of code that does one clear task.
2. Note what variables it uses or changes.
3. Create a new method with a clear name.
4. Move the piece there, adding needed parameters and returns.
5. Replace the old chunk with a call to the new method.
6. Compile and Test to confirm it works the same.

================= CODE TO REFACTOR =================

public void handleLine(final String inLine) {
    // JMH ???
    String line = inLine.replaceFirst("^ +", "");
    line = StringUtil.replaceXMLEntities(line);
    String trimmedLine = line.trim();
    if (DEBUG_LOGGING_ASSEMBLY) {
        logger.debug("handleLine:{}", line);
    }
    if (line.startsWith("[Disassembling for mach")) {
        architecture = Architecture.parseFromLogLine(line);
        if (architecture == null) {
            logger.error("Could not determine architecture from '{}'", line);
        } else {
            if (DEBUG_LOGGING_ASSEMBLY) {
                logger.debug("Detected architecture: {}", architecture);
            }
        }
    }
    if (S_HASH.equals(previousLine) && line.startsWith("{method}")) {
        if (DEBUG_LOGGING_ASSEMBLY) {
            logger.debug("fixup mangled {method} line");
        }
        line = S_HASH + S_SPACE + line;
    }
    if (trimmedLine.startsWith("total in heap")) {
        String possibleNativeAddress = getStartAddress(line);
        if (possibleNativeAddress != null) {
            nativeAddress = possibleNativeAddress.trim();
        }
    }
    if (trimmedLine.endsWith(" bytes") || trimmedLine.startsWith("main code")) {
        String possibleEntryAddress = getStartAddress(line);
        if (possibleEntryAddress != null) {
            entryAddress = possibleEntryAddress.trim();
        }
    }
    if (trimmedLine.endsWith("</print_nmethod>")) {
        complete();
    }
    if (line.startsWith(NATIVE_CODE_START) || line.startsWith("Compiled method") || line.startsWith("----------------------------------------------------------------------")) {
        if (DEBUG_LOGGING_ASSEMBLY) {
            logger.debug("Assembly started");
        }
        assemblyStarted = true;
        if (builder.length() > 0) {
            complete();
        }
        String possibleNativeAddress = StringUtil.getSubstringBetween(line, NATIVE_CODE_START, S_COLON);
        if (possibleNativeAddress != null) {
            nativeAddress = possibleNativeAddress.trim();
        }
    } else if (assemblyStarted) {
        boolean couldBeNativeMethodMark = false;
        couldBeNativeMethodMark = line.startsWith(NATIVE_CODE_METHOD_MARK);
        if (couldBeNativeMethodMark) {
            if (DEBUG_LOGGING_ASSEMBLY) {
                logger.debug("Assembly method started");
            }
            methodStarted = true;
            if (!line.endsWith(S_APOSTROPHE)) {
                if (DEBUG_LOGGING_ASSEMBLY) {
                    logger.debug("Method signature interrupted");
                }
                methodInterrupted = true;
            }
        } else if (methodInterrupted && line.endsWith(S_APOSTROPHE)) {
            methodInterrupted = false;
        }
        if (methodStarted && line.length() > 0) {
            builder.append(line);
            if (!methodInterrupted) {
                builder.append(S_NEWLINE);
            }
        }
    }
    previousLine = line;
}

================= OUTPUT FORMAT =================


Return the result strictly using the format below:
<refactored code>
[The code after the refactoring should be between these tags.]
</refactored code>
<refactoring explanation>
[The explanation of the refactoring should be between these tags.]
</refactoring explanation>