You are an expert in refactoring code snippets. Here are some examples of refactoring using the Extract Method technique.

================= EXAMPLES =================

Example 1:

Refactoring Description: Extract Method public hasAmmo(tile Tile) : boolean extracted from public update(tile Tile) : void in class io.anuke.mindustry.world.blocks.types.defense.Turret

Code Before:
------------
@@ -35,7 +35,7 @@ public class Turret extends Block{
 	protected int ammoMultiplier = 20;
 	protected int maxammo = 400;
 	protected float rotatespeed = 0.2f;
-	protected float shootCone = 2f;
 
 	public Turret(String name) {
 		super(name);
@@ -112,7 +112,7 @@ public void update(Tile tile){
 		if(entity.target != null && entity.target.isDead())
 			entity.target = null;
 		
-		if(entity.ammo > 0){
 			
 			if(Timers.get(entity, "target", targetInterval)){
 				entity.target = (Enemy)Entities.getClosest(tile.worldx(), tile.worldy(), range, e->{
@@ -132,12 +132,23 @@ public void update(Tile tile){
 				if(Angles.angleDist(entity.rotation, targetRot) < shootCone && Timers.get(tile, "reload", reload)){
 					Effects.sound(shootsound, entity);
 					shoot(tile);
 					entity.ammo --;
 				}
 			}
 		}
 	}
 	
 	@Override
 	public TileEntity getEntity(){
 		return new TurretEntity();

Code After:
------------
@@ -35,7 +35,7 @@ public class Turret extends Block{
 	protected int ammoMultiplier = 20;
 	protected int maxammo = 400;
 	protected float rotatespeed = 0.2f;
+	protected float shootCone = 5f;
 
 	public Turret(String name) {
 		super(name);
@@ -112,7 +112,7 @@ public void update(Tile tile){
 		if(entity.target != null && entity.target.isDead())
 			entity.target = null;
 		
+		if(hasAmmo(tile)){
 			
 			if(Timers.get(entity, "target", targetInterval)){
 				entity.target = (Enemy)Entities.getClosest(tile.worldx(), tile.worldy(), range, e->{
@@ -132,12 +132,23 @@ public void update(Tile tile){
 				if(Angles.angleDist(entity.rotation, targetRot) < shootCone && Timers.get(tile, "reload", reload)){
 					Effects.sound(shootsound, entity);
 					shoot(tile);
+					consumeAmmo(tile);
 					entity.ammo --;
 				}
 			}
 		}
 	}
 	
+	public boolean hasAmmo(Tile tile){
+		TurretEntity entity = tile.entity();
+		return entity.ammo > 0;
+	}
+	
+	public void consumeAmmo(Tile tile){
+		TurretEntity entity = tile.entity();
+		entity.ammo --;
+	}
+	
 	@Override
 	public TileEntity getEntity(){
 		return new TurretEntity();

Example 2:

Refactoring Description: Extract Method protected configureFailedDbEntityOperation(operation DbEntityOperation, failure Exception) : void extracted from protected entityInsertPerformed(operation DbEntityOperation, rowsAffected int, failure Exception) : void in class org.camunda.bpm.engine.impl.db.sql.DbSqlSession

Code Before:
------------
@@ -142,14 +142,7 @@ protected void entityUpdatePerformed(DbEntityOperation operation,
                                        int rowsAffected,
                                        Exception failure) {
     if (failure != null) {
-      operation.setRowsAffected(0);
-      operation.setFailure(failure);
-
-      if (isConcurrentModificationException(operation, failure)) {
-        operation.setState(State.FAILED_CONCURRENT_MODIFICATION);
-      } else {
-        operation.setState(State.FAILED_ERROR);
-      }
     } else {
       DbEntity dbEntity = operation.getEntity();
 
@@ -189,7 +182,13 @@ protected void bulkOperationPerformed(DbBulkOperation operation,
 
     if (failure != null) {
       operation.setFailure(failure);
-      operation.setState(State.FAILED_ERROR);
     } else {
       operation.setRowsAffected(rowsAffected);
       operation.setState(State.APPLIED);
@@ -201,20 +200,7 @@ protected void entityDeletePerformed(DbEntityOperation operation,
                                        Exception failure) {
     
     if (failure != null) {
-      operation.setRowsAffected(0);
-      operation.setFailure(failure);
-
-      DbOperation dependencyOperation = operation.getDependentOperation();
-
-      if (isConcurrentModificationException(operation, failure)) {
-        operation.setState(State.FAILED_CONCURRENT_MODIFICATION);
-      } else if (dependencyOperation != null && dependencyOperation.getState() != null && dependencyOperation.getState() != State.APPLIED) {
-        // the owning operation was not successful, so the prerequisite for this operation was not given
-        LOG.ignoreFailureDuePreconditionNotMet(operation, "Parent database operation failed", dependencyOperation);
-        operation.setState(State.NOT_APPLIED);
-      } else {
-        operation.setState(State.FAILED_ERROR);
-      }
     } else {
       operation.setRowsAffected(rowsAffected);
 
@@ -229,6 +215,36 @@ protected void entityDeletePerformed(DbEntityOperation operation,
     }
   }
 
   protected boolean isConcurrentModificationException(DbOperation failedOperation,
                                                       Exception cause) {
 
@@ -259,6 +275,30 @@ protected boolean isConcurrentModificationException(DbOperation failedOperation,
     return false;
   }
 
   // insert //////////////////////////////////////////
 
   @Override
@@ -291,14 +331,7 @@ protected void entityInsertPerformed(DbEntityOperation operation,
     DbEntity entity = operation.getEntity();
 
     if (failure != null) {
-      operation.setRowsAffected(0);
-      operation.setFailure(failure);
-
-      if (isConcurrentModificationException(operation, failure)) {
-        operation.setState(State.FAILED_CONCURRENT_MODIFICATION);
-      } else {
-        operation.setState(State.FAILED_ERROR);
-      }
     } else {
       // set revision of our copy to 1
       if (entity instanceof HasDbRevision) {

Code After:
------------
@@ -142,14 +142,7 @@ protected void entityUpdatePerformed(DbEntityOperation operation,
                                        int rowsAffected,
                                        Exception failure) {
     if (failure != null) {
+      configureFailedDbEntityOperation(operation, failure);
     } else {
       DbEntity dbEntity = operation.getEntity();
 
@@ -189,7 +182,13 @@ protected void bulkOperationPerformed(DbBulkOperation operation,
 
     if (failure != null) {
       operation.setFailure(failure);
+
+      State failedState = State.FAILED_ERROR;
+      if (isCrdbTransactionRetryException(failure)) {
+        failedState = State.FAILED_CONCURRENT_MODIFICATION;
+        operation.setFatalFailure(true);
+      }
+      operation.setState(failedState);
     } else {
       operation.setRowsAffected(rowsAffected);
       operation.setState(State.APPLIED);
@@ -201,20 +200,7 @@ protected void entityDeletePerformed(DbEntityOperation operation,
                                        Exception failure) {
     
     if (failure != null) {
+      configureFailedDbEntityOperation(operation, failure);
     } else {
       operation.setRowsAffected(rowsAffected);
 
@@ -229,6 +215,36 @@ protected void entityDeletePerformed(DbEntityOperation operation,
     }
   }
 
+  protected void configureFailedDbEntityOperation(DbEntityOperation operation, Exception failure) {
+    operation.setRowsAffected(0);
+    operation.setFailure(failure);
+
+    DbOperationType operationType = operation.getOperationType();
+    DbOperation dependencyOperation = operation.getDependentOperation();
+
+    State failedState;
+    if (isCrdbTransactionRetryException(failure)) {
+
+      operation.setFatalFailure(true);
+      failedState = State.FAILED_CONCURRENT_MODIFICATION;
+    } else if (isConcurrentModificationException(operation, failure)) {
+
+      failedState = State.FAILED_CONCURRENT_MODIFICATION;
+    } else if (DbOperationType.DELETE.equals(operationType)
+              && dependencyOperation != null
+              && dependencyOperation.getState() != null
+              && dependencyOperation.getState() != State.APPLIED) {
+
+      // the owning operation was not successful, so the prerequisite for this operation was not given
+      LOG.ignoreFailureDuePreconditionNotMet(operation, "Parent database operation failed", dependencyOperation);
+      failedState = State.NOT_APPLIED;
+    } else {
+
+      failedState = State.FAILED_ERROR;
+    }
+    operation.setState(failedState);
+  }
+
   protected boolean isConcurrentModificationException(DbOperation failedOperation,
                                                       Exception cause) {
 
@@ -259,6 +275,30 @@ protected boolean isConcurrentModificationException(DbOperation failedOperation,
     return false;
   }
 
+  /**
+   * In cases where CockroachDB is used, and a failed operation is detected,
+   * the method checks if the exception was caused by a CockroachDB
+   * <code>TransactionRetryException</code>.
+   *
+   * @param cause for which an operation failed
+   * @return true if the failure was due to a CRDB <code>TransactionRetryException</code>.
+   *          Otherwise, it's false.
+   */
+  protected boolean isCrdbTransactionRetryException(Throwable cause) {
+    // only check when CRDB is used
+    String databaseType = Context.getProcessEngineConfiguration().getDatabaseType();
+    if (DbSqlSessionFactory.CRDB.equals(databaseType)) {
+      boolean isCrdbTxRetryException = ExceptionUtil.checkCrdbTransactionRetryException(cause);
+      if (isCrdbTxRetryException) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+
+
   // insert //////////////////////////////////////////
 
   @Override
@@ -291,14 +331,7 @@ protected void entityInsertPerformed(DbEntityOperation operation,
     DbEntity entity = operation.getEntity();
 
     if (failure != null) {
+      configureFailedDbEntityOperation(operation, failure);
     } else {
       // set revision of our copy to 1
       if (entity instanceof HasDbRevision) {

Example 3:

Refactoring Description: Extract Method private getSourceSection(context LazyContext) : SourceSection extracted from public getSourceSection() : SourceSection in class com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation

Code Before:
------------
@@ -32,8 +32,10 @@
 import com.oracle.truffle.api.CompilerAsserts;
 import com.oracle.truffle.api.CompilerDirectives.CompilationFinal;
 import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
 import com.oracle.truffle.api.source.Source;
 import com.oracle.truffle.api.source.SourceSection;
 import com.oracle.truffle.llvm.runtime.global.LLVMGlobal;
 
 import java.nio.file.InvalidPathException;
@@ -47,8 +49,14 @@
 
 public abstract class LLVMSourceLocation {
 
     public abstract static class LazySourceSection {
-        public abstract SourceSection get();
 
         public abstract String getPath();
 
@@ -106,10 +114,26 @@ private LLVMSourceLocation(LLVMSourceLocation parent, Kind kind, String name, So
         this.sourceSection = sourceSection;
     }
 
-    public synchronized SourceSection getSourceSection() {
         CompilerAsserts.neverPartOfCompilation();
         if (sourceSection == null && lazySourceSection != null) {
-            sourceSection = lazySourceSection.get();
         }
         return sourceSection != null ? sourceSection : UNAVAILABLE_SECTION;
     }

Code After:
------------
@@ -32,8 +32,10 @@
 import com.oracle.truffle.api.CompilerAsserts;
 import com.oracle.truffle.api.CompilerDirectives.CompilationFinal;
 import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
+import com.oracle.truffle.api.TruffleLanguage.ContextReference;
 import com.oracle.truffle.api.source.Source;
 import com.oracle.truffle.api.source.SourceSection;
+import com.oracle.truffle.llvm.runtime.LLVMContext;
 import com.oracle.truffle.llvm.runtime.global.LLVMGlobal;
 
 import java.nio.file.InvalidPathException;
@@ -47,8 +49,14 @@
 
 public abstract class LLVMSourceLocation {
 
+    @FunctionalInterface
+    public interface LazyContext {
+
+        LLVMContext get();
+    }
+
     public abstract static class LazySourceSection {
+        public abstract SourceSection get(LazyContext context);
 
         public abstract String getPath();
 
@@ -106,10 +114,26 @@ private LLVMSourceLocation(LLVMSourceLocation parent, Kind kind, String name, So
         this.sourceSection = sourceSection;
     }
 
+    public synchronized SourceSection getSourceSection(ContextReference<LLVMContext> ctxRef) {
+        CompilerAsserts.neverPartOfCompilation();
+        return getSourceSection(() -> {
+            try {
+                return ctxRef.get();
+            } catch (Throwable t) {
+                return null;
+            }
+        });
+    }
+
+    public SourceSection getSourceSection(LLVMContext context) {
+        CompilerAsserts.neverPartOfCompilation();
+        return getSourceSection(() -> context);
+    }
+
+    private synchronized SourceSection getSourceSection(LazyContext context) {
         CompilerAsserts.neverPartOfCompilation();
         if (sourceSection == null && lazySourceSection != null) {
+            sourceSection = lazySourceSection.get(context);
         }
         return sourceSection != null ? sourceSection : UNAVAILABLE_SECTION;
     }

================= REFACTORING MECHANICS =================

Please provide a refactored version of the code snippets above using the Extract Method technique, following these mechanics: 

1. Find a piece of code that does one clear task.
2. Note what variables it uses or changes.
3. Create a new method with a clear name.
4. Move the piece there, adding needed parameters and returns.
5. Replace the old chunk with a call to the new method.
6. Compile and Test to confirm it works the same.

================= CODE TO REFACTOR =================

private void visitTagEliminateAllocation(Tag tagEliminateAllocation, IParseDictionary parseDictionary) {
    List<Tag> childrenJVMS = tagEliminateAllocation.getNamedChildren(TAG_JVMS);
    String typeID = tagEliminateAllocation.getAttributes().get(ATTR_TYPE);
    String typeOrKlassName = null;
    if (typeID != null) {
        typeOrKlassName = ParseUtil.lookupType(typeID, parseDictionary);
        if (typeOrKlassName != null) {
            for (Tag tagJVMS : childrenJVMS) {
                Map<String, String> tagJVMSAttributes = tagJVMS.getAttributes();
                String attrBCI = tagJVMSAttributes.get(ATTR_BCI);
                int bciValue = 0;
                if (attrBCI != null) {
                    try {
                        bciValue = Integer.parseInt(attrBCI);
                    } catch (NumberFormatException nfe) {
                        logger.error("Couldn't parse bci attribute {} tag {}", attrBCI, tagJVMS.toString(true));
                        continue;
                    }
                } else {
                    logger.error("Missing bci attribute on tag {}", tagJVMS.toString(true));
                }
                String methodID = tagJVMSAttributes.get(ATTR_METHOD);
                BCIOpcodeMap bciOpcodeMap = parseDictionary.getBCIOpcodeMap(methodID);
                //logger.info("method {} {} {}", methodID, parseDictionary.getParseMethod(), bciOpcodeMap.entrySet());
                if (CompilationUtil.memberMatchesMethodID(currentMember, methodID, parseDictionary)) {
                    storeEliminatedAllocation(currentMember, bciValue, typeOrKlassName, bciOpcodeMap);
                } else if (processAnnotationsForInlinedMethods) {
                    IMetaMember inlinedMember = findMemberForInlinedMethod(tagJVMS, parseDictionary);
                    if (inlinedMember != null) {
                        storeEliminatedAllocation(inlinedMember, bciValue, typeOrKlassName, bciOpcodeMap);
                    } else {
                        unhandledTags.add(tagJVMS);
                    }
                }
            }
        } else {
            logger.error("Unknown type attribute {} on tag {}", typeID, tagEliminateAllocation.toString(true));
        }
    } else {
        logger.error("Missing type attribute on tag {}", tagEliminateAllocation.toString(true));
    }
}

================= OUTPUT FORMAT =================


Return the result strictly using the format below:
<refactored code>
[The code after the refactoring should be between these tags.]
</refactored code>
<refactoring explanation>
[The explanation of the refactoring should be between these tags.]
</refactoring explanation>