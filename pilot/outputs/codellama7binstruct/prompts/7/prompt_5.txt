You are an expert in refactoring code snippets. Here are some examples of refactoring using the Extract Method technique.

================= EXAMPLES =================

Example 1:

Refactoring Description: Extract Method private removeImageImpl(image Image) : void extracted from public removeImage(image Image) : void in class java.awt.MediaTracker

Code Before:
------------
@@ -28,6 +28,7 @@
 import java.awt.Component;
 import java.awt.Image;
 import java.awt.image.ImageObserver;
 
 /**
  * The <code>MediaTracker</code> class is a utility class to track
@@ -222,10 +223,17 @@ public void addImage(Image image, int id) {
      * @param     h    the height at which the image is rendered
      */
     public synchronized void addImage(Image image, int id, int w, int h) {
         head = MediaEntry.insert(head,
                                  new ImageMediaEntry(this, image, id, w, h));
     }
-
     /**
      * Flag indicating that media is currently being loaded.
      * @see         java.awt.MediaTracker#statusAll
@@ -719,6 +727,15 @@ private synchronized int statusID(int id, boolean load, boolean verify) {
      * @since   JDK1.1
      */
     public synchronized void removeImage(Image image) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -735,7 +752,6 @@ public synchronized void removeImage(Image image) {
             }
             cur = next;
         }
-        notifyAll();    // Notify in case remaining images are "done".
     }
 
     /**
@@ -750,6 +766,15 @@ public synchronized void removeImage(Image image) {
      * @since      JDK1.1
      */
     public synchronized void removeImage(Image image, int id) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -766,7 +791,6 @@ public synchronized void removeImage(Image image, int id) {
             }
             cur = next;
         }
-        notifyAll();    // Notify in case remaining images are "done".
     }
 
     /**
@@ -783,6 +807,16 @@ public synchronized void removeImage(Image image, int id) {
      */
     public synchronized void removeImage(Image image, int id,
                                          int width, int height) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -801,12 +835,18 @@ public synchronized void removeImage(Image image, int id,
             }
             cur = next;
         }
-        notifyAll();    // Notify in case remaining images are "done".
     }
 
     synchronized void setDone() {
         notifyAll();
     }
 }
 
 abstract class MediaEntry {

Code After:
------------
@@ -28,6 +28,7 @@
 import java.awt.Component;
 import java.awt.Image;
 import java.awt.image.ImageObserver;
+import sun.awt.image.MultiResolutionToolkitImage;
 
 /**
  * The <code>MediaTracker</code> class is a utility class to track
@@ -222,10 +223,17 @@ public void addImage(Image image, int id) {
      * @param     h    the height at which the image is rendered
      */
     public synchronized void addImage(Image image, int id, int w, int h) {
+        addImageImpl(image, id, w, h);
+        Image rvImage = getResolutionVariant(image);
+        if (rvImage != null) {
+            addImageImpl(rvImage, id, 2 * w, 2 * h);
+        }
+    }
+
+    private void addImageImpl(Image image, int id, int w, int h) {
         head = MediaEntry.insert(head,
                                  new ImageMediaEntry(this, image, id, w, h));
     }
     /**
      * Flag indicating that media is currently being loaded.
      * @see         java.awt.MediaTracker#statusAll
@@ -719,6 +727,15 @@ private synchronized int statusID(int id, boolean load, boolean verify) {
      * @since   JDK1.1
      */
     public synchronized void removeImage(Image image) {
+        removeImageImpl(image);
+        Image rvImage = getResolutionVariant(image);
+        if (rvImage != null) {
+            removeImageImpl(rvImage);
+        }
+        notifyAll();    // Notify in case remaining images are "done".
+    }
+
+    private void removeImageImpl(Image image) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -735,7 +752,6 @@ public synchronized void removeImage(Image image) {
             }
             cur = next;
         }
     }
 
     /**
@@ -750,6 +766,15 @@ public synchronized void removeImage(Image image) {
      * @since      JDK1.1
      */
     public synchronized void removeImage(Image image, int id) {
+        removeImageImpl(image, id);
+        Image rvImage = getResolutionVariant(image);
+        if (rvImage != null) {
+            removeImageImpl(rvImage, id);
+        }
+        notifyAll();    // Notify in case remaining images are "done".
+    }
+
+    private void removeImageImpl(Image image, int id) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -766,7 +791,6 @@ public synchronized void removeImage(Image image, int id) {
             }
             cur = next;
         }
     }
 
     /**
@@ -783,6 +807,16 @@ public synchronized void removeImage(Image image, int id) {
      */
     public synchronized void removeImage(Image image, int id,
                                          int width, int height) {
+        removeImageImpl(image, id, width, height);
+        Image rvImage = getResolutionVariant(image);
+        if (rvImage != null) {
+            removeImageImpl(rvImage, id, 2 * width, 2 * height);
+
+        }
+        notifyAll();    // Notify in case remaining images are "done".
+    }
+
+    private void removeImageImpl(Image image, int id, int width, int height) {
         MediaEntry cur = head;
         MediaEntry prev = null;
         while (cur != null) {
@@ -801,12 +835,18 @@ public synchronized void removeImage(Image image, int id,
             }
             cur = next;
         }
     }
 
     synchronized void setDone() {
         notifyAll();
     }
+
+    private static Image getResolutionVariant(Image image) {
+        if (image instanceof MultiResolutionToolkitImage) {
+            return ((MultiResolutionToolkitImage) image).getResolutionVariant();
+        }
+        return null;
+    }
 }
 
 abstract class MediaEntry {

Example 2:

Refactoring Description: Extract Method protected newSPDYServerConnector(listener ServerSessionFrameListener) : Connector extracted from protected startServer(listener ServerSessionFrameListener) : InetSocketAddress in class org.eclipse.jetty.spdy.SPDYTest

Code Before:
------------
@@ -8,35 +8,58 @@
 import org.eclipse.jetty.spdy.api.server.ServerSessionFrameListener;
 import org.eclipse.jetty.spdy.nio.SPDYClient;
 import org.eclipse.jetty.spdy.nio.SPDYServerConnector;
 import org.eclipse.jetty.util.thread.QueuedThreadPool;
 import org.junit.After;
 
-public class SPDYTest
 {
     private Server server;
     private SPDYClient.Factory clientFactory;
 
     protected InetSocketAddress startServer(ServerSessionFrameListener listener) throws Exception
     {
         server = new Server();
-        Connector connector = new SPDYServerConnector(listener);
         server.addConnector(connector);
         server.start();
         return new InetSocketAddress(connector.getLocalPort());
     }
 
     protected Session startClient(InetSocketAddress socketAddress, Session.FrameListener frameListener) throws Exception
     {
         if (clientFactory == null)
         {
             QueuedThreadPool threadPool = new QueuedThreadPool();
             threadPool.setName(threadPool.getName() + "-client");
-            clientFactory = new SPDYClient.Factory(threadPool);
             clientFactory.start();
         }
         return clientFactory.newSPDYClient().connect(socketAddress, frameListener).get();
     }
 
     @After
     public void destroy() throws Exception
     {

Code After:
------------
@@ -8,35 +8,58 @@
 import org.eclipse.jetty.spdy.api.server.ServerSessionFrameListener;
 import org.eclipse.jetty.spdy.nio.SPDYClient;
 import org.eclipse.jetty.spdy.nio.SPDYServerConnector;
+import org.eclipse.jetty.util.ssl.SslContextFactory;
 import org.eclipse.jetty.util.thread.QueuedThreadPool;
+import org.eclipse.jetty.util.thread.ThreadPool;
 import org.junit.After;
 
+public abstract class SPDYTest
 {
     private Server server;
     private SPDYClient.Factory clientFactory;
 
     protected InetSocketAddress startServer(ServerSessionFrameListener listener) throws Exception
     {
         server = new Server();
+        Connector connector = newSPDYServerConnector(listener);
         server.addConnector(connector);
         server.start();
         return new InetSocketAddress(connector.getLocalPort());
     }
 
+    protected Connector newSPDYServerConnector(ServerSessionFrameListener listener)
+    {
+        return new SPDYServerConnector(listener);
+    }
+
     protected Session startClient(InetSocketAddress socketAddress, Session.FrameListener frameListener) throws Exception
     {
         if (clientFactory == null)
         {
             QueuedThreadPool threadPool = new QueuedThreadPool();
             threadPool.setName(threadPool.getName() + "-client");
+            clientFactory = newSPDYClientFactory(threadPool);
             clientFactory.start();
         }
         return clientFactory.newSPDYClient().connect(socketAddress, frameListener).get();
     }
 
+    protected SPDYClient.Factory newSPDYClientFactory(ThreadPool threadPool)
+    {
+        return new SPDYClient.Factory(threadPool);
+    }
+
+    protected SslContextFactory newSslContextFactory()
+    {
+        SslContextFactory sslContextFactory = new SslContextFactory();
+        sslContextFactory.setKeyStorePath("src/test/resources/keystore.jks");
+        sslContextFactory.setKeyStorePassword("storepwd");
+        sslContextFactory.setTrustStore("src/test/resources/truststore.jks");
+        sslContextFactory.setTrustStorePassword("storepwd");
+        sslContextFactory.setProtocol("TLSv1");
+        return sslContextFactory;
+    }
+
     @After
     public void destroy() throws Exception
     {

Example 3:

Refactoring Description: Extract Method public renderPng(out OutputStream, width int, height int, hideLegend boolean, hideGrid boolean, hideTitle boolean, showEvents boolean, periodCount int, end int, showCredit boolean, lsnr2 SummaryListener, titleOverride String) : void extracted from public renderPng(out OutputStream, width int, height int, hideLegend boolean, hideGrid boolean, hideTitle boolean, showEvents boolean, periodCount int, end int, showCredit boolean) : void in class net.i2p.router.web.SummaryListener

Code Before:
------------
@@ -187,14 +187,31 @@ public void stopListening() {
     }
 
     /**
      *  @param end number of periods before now
      */
     public void renderPng(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid,
                           boolean hideTitle, boolean showEvents, int periodCount,
                           int end, boolean showCredit) throws IOException {
         if (_renderer == null || _db == null)
             throw new IOException("No RRD, check logs for previous errors");
-        _renderer.render(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount, end, showCredit); 
     }
 
     public void renderPng(OutputStream out) throws IOException {

Code After:
------------
@@ -187,14 +187,31 @@ public void stopListening() {
     }
 
     /**
+     *  Single graph.
+     *
      *  @param end number of periods before now
      */
     public void renderPng(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid,
                           boolean hideTitle, boolean showEvents, int periodCount,
                           int end, boolean showCredit) throws IOException {
+        renderPng(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount,
+                  end, showCredit, null, null); 
+    }
+
+    /**
+     *  Single or two-data-source graph.
+     *
+     *  @param lsnr2 2nd data source to plot on same graph, or null. Not recommended for events.
+     *  @param titleOverride If non-null, overrides the title
+     *  @since 0.9.6
+     */
+    public void renderPng(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid,
+                          boolean hideTitle, boolean showEvents, int periodCount,
+                          int end, boolean showCredit, SummaryListener lsnr2, String titleOverride) throws IOException {
         if (_renderer == null || _db == null)
             throw new IOException("No RRD, check logs for previous errors");
+        _renderer.render(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount,
+                         end, showCredit, lsnr2, titleOverride); 
     }
 
     public void renderPng(OutputStream out) throws IOException {

================= REFACTORING MECHANICS =================

Please provide a refactored version of the code snippets above using the Extract Method technique, following these mechanics: 

1. Find a piece of code that does one clear task.
2. Note what variables it uses or changes.
3. Create a new method with a clear name.
4. Move the piece there, adding needed parameters and returns.
5. Replace the old chunk with a call to the new method.
6. Compile and Test to confirm it works the same.

================= CODE TO REFACTOR =================

private void visitTagEliminateAllocation(Tag tagEliminateAllocation, IParseDictionary parseDictionary) {
    List<Tag> childrenJVMS = tagEliminateAllocation.getNamedChildren(TAG_JVMS);
    String typeID = tagEliminateAllocation.getAttributes().get(ATTR_TYPE);
    String typeOrKlassName = null;
    if (typeID != null) {
        typeOrKlassName = ParseUtil.lookupType(typeID, parseDictionary);
        if (typeOrKlassName != null) {
            for (Tag tagJVMS : childrenJVMS) {
                Map<String, String> tagJVMSAttributes = tagJVMS.getAttributes();
                String attrBCI = tagJVMSAttributes.get(ATTR_BCI);
                int bciValue = 0;
                if (attrBCI != null) {
                    try {
                        bciValue = Integer.parseInt(attrBCI);
                    } catch (NumberFormatException nfe) {
                        logger.error("Couldn't parse bci attribute {} tag {}", attrBCI, tagJVMS.toString(true));
                        continue;
                    }
                } else {
                    logger.error("Missing bci attribute on tag {}", tagJVMS.toString(true));
                }
                String methodID = tagJVMSAttributes.get(ATTR_METHOD);
                BCIOpcodeMap bciOpcodeMap = parseDictionary.getBCIOpcodeMap(methodID);
                //logger.info("method {} {} {}", methodID, parseDictionary.getParseMethod(), bciOpcodeMap.entrySet());
                if (CompilationUtil.memberMatchesMethodID(currentMember, methodID, parseDictionary)) {
                    storeEliminatedAllocation(currentMember, bciValue, typeOrKlassName, bciOpcodeMap);
                } else if (processAnnotationsForInlinedMethods) {
                    IMetaMember inlinedMember = findMemberForInlinedMethod(tagJVMS, parseDictionary);
                    if (inlinedMember != null) {
                        storeEliminatedAllocation(inlinedMember, bciValue, typeOrKlassName, bciOpcodeMap);
                    } else {
                        unhandledTags.add(tagJVMS);
                    }
                }
            }
        } else {
            logger.error("Unknown type attribute {} on tag {}", typeID, tagEliminateAllocation.toString(true));
        }
    } else {
        logger.error("Missing type attribute on tag {}", tagEliminateAllocation.toString(true));
    }
}

================= OUTPUT FORMAT =================


Return the result strictly using the format below:
<refactored code>
[The code after the refactoring should be between these tags.]
</refactored code>
<refactoring explanation>
[The explanation of the refactoring should be between these tags.]
</refactoring explanation>