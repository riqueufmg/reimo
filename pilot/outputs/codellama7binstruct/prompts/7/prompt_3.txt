You are an expert in refactoring code snippets. Here are some examples of refactoring using the Extract Method technique.

================= EXAMPLES =================

Example 1:

Refactoring Description: Extract Method protected removeNic(vm VirtualMachineProfile<? extends VMInstanceVO>, nic NicVO) : void extracted from public cleanupNics(vm VirtualMachineProfile<? extends VMInstanceVO>) : void in class com.cloud.network.NetworkManagerImpl

Code Before:
------------
@@ -2022,11 +2022,14 @@ public int compare(NicVO nic1, NicVO nic2) {
     }
 
     @Override
     public NicProfile prepareNic(VirtualMachineProfile<? extends VMInstanceVO> vmProfile, DeployDestination 
             dest, ReservationContext context, long nicId, NetworkVO network)
             throws InsufficientVirtualNetworkCapcityException, InsufficientAddressCapacityException, 
             ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {
         
         Integer networkRate = getNetworkRate(network.getId(), vmProfile.getId());
         NetworkGuru guru = _networkGurus.get(network.getGuruName());
         NicVO nic = _nicDao.findById(nicId);
@@ -2090,7 +2093,8 @@ public <T extends VMInstanceVO> void prepareNicForMigration(VirtualMachineProfil
             Integer networkRate = getNetworkRate(network.getId(), vm.getId());
 
             NetworkGuru guru = _networkGurus.get(network.getGuruName());
-            NicProfile profile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), networkRate, isSecurityGroupSupportedInNetwork(network), getNetworkTag(vm.getHypervisorType(), network));
             guru.updateNicProfile(profile, network);
             vm.addNic(profile);
         }
@@ -2105,6 +2109,18 @@ public void release(VirtualMachineProfile<? extends VMInstanceVO> vmProfile, boo
             releaseNic(vmProfile, nic, network);
         }
     }
 
     protected void releaseNic(VirtualMachineProfile<? extends VMInstanceVO> vmProfile, NicVO nic, NetworkVO network) 
             throws ConcurrentOperationException, ResourceUnavailableException {
@@ -2283,15 +2299,27 @@ public void cleanupNics(VirtualMachineProfile<? extends VMInstanceVO> vm) {
 
         List<NicVO> nics = _nicDao.listByVmId(vm.getId());
         for (NicVO nic : nics) {
-            nic.setState(Nic.State.Deallocating);
-            _nicDao.update(nic.getId(), nic);
-            NetworkVO network = _networksDao.findById(nic.getNetworkId());
-            NicProfile profile = new NicProfile(nic, network, null, null, null, isSecurityGroupSupportedInNetwork(network), getNetworkTag(vm.getHypervisorType(), network));
-            NetworkGuru guru = _networkGurus.get(network.getGuruName());
-            guru.deallocate(network, profile, vm);
-            _nicDao.remove(nic.getId());
         }
     }
 
     @Override
     public void expungeNics(VirtualMachineProfile<? extends VMInstanceVO> vm) {
@@ -2629,21 +2657,18 @@ protected Network createVpcGuestNetwork(long ntwkOffId, String name, String disp
             PhysicalNetwork pNtwk, long zoneId, ACLType aclType, Boolean subdomainAccess, long vpcId) 
                     throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {
         
         //1) Validate if network can be created for VPC
-        _vpcMgr.validateGuestNtkwForVpc(_configMgr.getNetworkOffering(ntwkOffId), cidr, networkDomain, owner, 
-                _vpcMgr.getVpc(vpcId));
         
         //2) Create network
         Network guestNetwork = createGuestNetwork(ntwkOffId, name, displayText, gateway, cidr, vlanId, 
                 networkDomain, owner, domainId, pNtwk, zoneId, aclType, subdomainAccess, vpcId);
         
-        //3) Add network to all VPC's routers
-        List<DomainRouterVO> routers = _routerDao.listRoutersByVpcId(vpcId);
-        for (DomainRouterVO router : routers) {
-            s_logger.debug("Adding router " + router + " to network " + guestNetwork);
-            _routerDao.addRouterToNetwork(router, guestNetwork);
-        }
-        
         return guestNetwork;
     }
 

Code After:
------------
@@ -2022,11 +2022,14 @@ public int compare(NicVO nic1, NicVO nic2) {
     }
 
     @Override
+    @DB
     public NicProfile prepareNic(VirtualMachineProfile<? extends VMInstanceVO> vmProfile, DeployDestination 
             dest, ReservationContext context, long nicId, NetworkVO network)
             throws InsufficientVirtualNetworkCapcityException, InsufficientAddressCapacityException, 
             ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {
         
+        
+        
         Integer networkRate = getNetworkRate(network.getId(), vmProfile.getId());
         NetworkGuru guru = _networkGurus.get(network.getGuruName());
         NicVO nic = _nicDao.findById(nicId);
@@ -2090,7 +2093,8 @@ public <T extends VMInstanceVO> void prepareNicForMigration(VirtualMachineProfil
             Integer networkRate = getNetworkRate(network.getId(), vm.getId());
 
             NetworkGuru guru = _networkGurus.get(network.getGuruName());
+            NicProfile profile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), networkRate, 
+                    isSecurityGroupSupportedInNetwork(network), getNetworkTag(vm.getHypervisorType(), network));
             guru.updateNicProfile(profile, network);
             vm.addNic(profile);
         }
@@ -2105,6 +2109,18 @@ public void release(VirtualMachineProfile<? extends VMInstanceVO> vmProfile, boo
             releaseNic(vmProfile, nic, network);
         }
     }
+    
+    @Override
+    public NicProfile releaseNic(VirtualMachineProfile<? extends VMInstanceVO> vmProfile, NetworkVO network) 
+            throws ConcurrentOperationException, ResourceUnavailableException {
+        NicVO nic = _nicDao.findByInstanceIdAndNetworkId(network.getId(), vmProfile.getId());
+        releaseNic(vmProfile, nic, network);
+        
+        NicProfile profile = new NicProfile(nic, network, nic.getBroadcastUri(), nic.getIsolationUri(), null, 
+                isSecurityGroupSupportedInNetwork(network), getNetworkTag(vmProfile.getVirtualMachine().getHypervisorType(), network));
+        return profile;
+    }
+    
 
     protected void releaseNic(VirtualMachineProfile<? extends VMInstanceVO> vmProfile, NicVO nic, NetworkVO network) 
             throws ConcurrentOperationException, ResourceUnavailableException {
@@ -2283,15 +2299,27 @@ public void cleanupNics(VirtualMachineProfile<? extends VMInstanceVO> vm) {
 
         List<NicVO> nics = _nicDao.listByVmId(vm.getId());
         for (NicVO nic : nics) {
+            removeNic(vm, nic);
         }
     }
+    
+    @Override
+    public void removeNic(VirtualMachineProfile<? extends VMInstanceVO> vm, Network network) {
+        NicVO nic = _nicDao.findByInstanceIdAndNetworkId(network.getId(), vm.getVirtualMachine().getId());
+        removeNic(vm, nic);
+    }
+
+    protected void removeNic(VirtualMachineProfile<? extends VMInstanceVO> vm, NicVO nic) {
+        nic.setState(Nic.State.Deallocating);
+        _nicDao.update(nic.getId(), nic);
+        NetworkVO network = _networksDao.findById(nic.getNetworkId());
+        NicProfile profile = new NicProfile(nic, network, null, null, null,
+                isSecurityGroupSupportedInNetwork(network), getNetworkTag(vm.getHypervisorType(), network));
+        NetworkGuru guru = _networkGurus.get(network.getGuruName());
+        guru.deallocate(network, profile, vm);
+        _nicDao.remove(nic.getId());
+        s_logger.debug("Removed nic id=" + nic.getId());
+    }
 
     @Override
     public void expungeNics(VirtualMachineProfile<? extends VMInstanceVO> vm) {
@@ -2629,21 +2657,18 @@ protected Network createVpcGuestNetwork(long ntwkOffId, String name, String disp
             PhysicalNetwork pNtwk, long zoneId, ACLType aclType, Boolean subdomainAccess, long vpcId) 
                     throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {
         
+        Vpc vpc = _vpcMgr.getVpc(vpcId);
         //1) Validate if network can be created for VPC
+        _vpcMgr.validateGuestNtkwForVpc(_configMgr.getNetworkOffering(ntwkOffId), cidr, networkDomain, owner, vpc);
+        
+        if (networkDomain == null) {
+            networkDomain = vpc.getNetworkDomain();
+        }
         
         //2) Create network
         Network guestNetwork = createGuestNetwork(ntwkOffId, name, displayText, gateway, cidr, vlanId, 
                 networkDomain, owner, domainId, pNtwk, zoneId, aclType, subdomainAccess, vpcId);
         
         return guestNetwork;
     }
 

Example 2:

Refactoring Description: Extract Method public convertDpToPixel(res Resources, dp int) : int extracted from public convertDpToPixel(ctx Context, dp int) : int in class com.liskovsoft.smartyoutubetv2.tv.ui.common.Utils

Code Before:
------------
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
 import android.graphics.Point;
 import android.media.MediaMetadataRetriever;
 import android.os.Build;
@@ -44,7 +45,11 @@ public static Point getDisplaySize(Context context) {
     }
 
     public static int convertDpToPixel(Context ctx, int dp) {
-        float density = ctx.getResources().getDisplayMetrics().density;
         return Math.round((float) dp * density);
     }
 

Code After:
------------
@@ -2,6 +2,7 @@
 
 import android.app.Activity;
 import android.content.Context;
+import android.content.res.Resources;
 import android.graphics.Point;
 import android.media.MediaMetadataRetriever;
 import android.os.Build;
@@ -44,7 +45,11 @@ public static Point getDisplaySize(Context context) {
     }
 
     public static int convertDpToPixel(Context ctx, int dp) {
+        return convertDpToPixel(ctx.getResources(), dp);
+    }
+
+    public static int convertDpToPixel(Resources res, int dp) {
+        float density = res.getDisplayMetrics().density;
         return Math.round((float) dp * density);
     }
 

Example 3:

Refactoring Description: Extract Method private convertReportsToVariableQuery(mappingFunction Function<ReportDefinitionDto,T>, reportDefinitionDtos List<ReportDefinitionDto>) : List<T> extracted from private convertAuthorizedReportsToVariableQuery(userId String, reportIds List<String>, mappingFunction Function<ReportDefinitionDto,T>) : List<T> in class org.camunda.optimize.service.variable.ProcessVariableService

Code Before:
------------
@@ -28,7 +28,6 @@
 import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 import static org.camunda.optimize.service.util.ValidationHelper.ensureNotEmpty;
 
@@ -55,7 +54,16 @@ public List<ProcessVariableNameResponseDto> getVariableNames(String userId,
     return processVariableReader.getVariableNames(variableRequestDto);
   }
 
-  public List<ProcessVariableNameResponseDto> getVariableNamesForReports(String userId, List<String> reportIds) {
     final List<ProcessVariableNameRequestDto> processVariableNameRequestDtos = convertAuthorizedReportsToVariableQuery(
       userId,
       reportIds,
@@ -103,25 +111,44 @@ public List<String> getVariableValuesForReports(String userId, ProcessVariableRe
     );
   }
 
   private <T> List<T> convertAuthorizedReportsToVariableQuery(final String userId,
                                                               final List<String> reportIds,
                                                               final Function<ReportDefinitionDto, T> mappingFunction) {
-    final List<? extends ReportDefinitionDto> allAuthorizedReportsForIds = reportService.getAllAuthorizedReportsForIds(
       userId,
       reportIds
     );
-    final Stream<? extends ReportDefinitionDto> reportsFromCombinedReports = allAuthorizedReportsForIds.stream()
-      .filter(reportDefinitionDto -> reportDefinitionDto instanceof CombinedReportDefinitionDto)
-      .flatMap(combinedReport -> {
-        final List<String> reportIdsFromCombined = ((CombinedReportDefinitionDto) combinedReport).getData()
-          .getReportIds();
-        return reportService.getAllAuthorizedReportsForIds(userId, reportIdsFromCombined).stream();
-      });
-
-    return Stream.concat(
-      allAuthorizedReportsForIds.stream(),
-      reportsFromCombinedReports
-    )
       .distinct()
       .filter(SingleProcessReportDefinitionDto.class::isInstance)
       .map(mappingFunction)

Code After:
------------
@@ -28,7 +28,6 @@
 import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
 import static org.camunda.optimize.service.util.ValidationHelper.ensureNotEmpty;
 
@@ -55,7 +54,16 @@ public List<ProcessVariableNameResponseDto> getVariableNames(String userId,
     return processVariableReader.getVariableNames(variableRequestDto);
   }
 
+  public List<ProcessVariableNameResponseDto> getVariableNamesForReports(List<String> reportIds) {
+    final List<ProcessVariableNameRequestDto> processVariableNameRequestDtos = convertReportsToVariableQuery(
+      reportIds,
+      definitionDto -> convertToProcessVariableNameRequest((SingleProcessReportDefinitionDto) definitionDto)
+    );
+    return processVariableReader.getVariableNames(processVariableNameRequestDtos);
+  }
+
+  public List<ProcessVariableNameResponseDto> getVariableNamesForAuthorizedReports(String userId,
+                                                                                   List<String> reportIds) {
     final List<ProcessVariableNameRequestDto> processVariableNameRequestDtos = convertAuthorizedReportsToVariableQuery(
       userId,
       reportIds,
@@ -103,25 +111,44 @@ public List<String> getVariableValuesForReports(String userId, ProcessVariableRe
     );
   }
 
+  private <T> List<T> convertReportsToVariableQuery(final List<String> reportIds,
+                                                    final Function<ReportDefinitionDto, T> mappingFunction) {
+    final List<ReportDefinitionDto> allReportsForIds = reportService.getAllReportsForIds(reportIds);
+    allReportsForIds.addAll(
+      allReportsForIds.stream()
+        .filter(reportDefinitionDto -> reportDefinitionDto instanceof CombinedReportDefinitionDto)
+        .flatMap(combinedReport -> {
+          final List<String> reportIdsFromCombined =
+            ((CombinedReportDefinitionDto) combinedReport).getData().getReportIds();
+          return reportService.getAllReportsForIds(reportIdsFromCombined).stream();
+        })
+        .collect(Collectors.toList()));
+
+    return convertReportsToVariableQuery(mappingFunction, allReportsForIds);
+  }
+
   private <T> List<T> convertAuthorizedReportsToVariableQuery(final String userId,
                                                               final List<String> reportIds,
                                                               final Function<ReportDefinitionDto, T> mappingFunction) {
+    final List<ReportDefinitionDto> allAuthorizedReportsForIds = reportService.getAllAuthorizedReportsForIds(
       userId,
       reportIds
     );
+    allAuthorizedReportsForIds.addAll(
+      allAuthorizedReportsForIds.stream()
+        .filter(reportDefinitionDto -> reportDefinitionDto instanceof CombinedReportDefinitionDto)
+        .flatMap(combinedReport -> {
+          final List<String> reportIdsFromCombined = ((CombinedReportDefinitionDto) combinedReport).getData()
+            .getReportIds();
+          return reportService.getAllAuthorizedReportsForIds(userId, reportIdsFromCombined).stream();
+        }).collect(Collectors.toList()));
+    return convertReportsToVariableQuery(mappingFunction, allAuthorizedReportsForIds);
+  }
+
+  private <T> List<T> convertReportsToVariableQuery(final Function<ReportDefinitionDto, T> mappingFunction,
+                                                    final List<ReportDefinitionDto> reportDefinitionDtos) {
+    return reportDefinitionDtos
+      .stream()
       .distinct()
       .filter(SingleProcessReportDefinitionDto.class::isInstance)
       .map(mappingFunction)

================= REFACTORING MECHANICS =================

Please provide a refactored version of the code snippets above using the Extract Method technique, following these mechanics: 

1. Find a piece of code that does one clear task.
2. Note what variables it uses or changes.
3. Create a new method with a clear name.
4. Move the piece there, adding needed parameters and returns.
5. Replace the old chunk with a call to the new method.
6. Compile and Test to confirm it works the same.

================= CODE TO REFACTOR =================

private void visitTagEliminateAllocation(Tag tagEliminateAllocation, IParseDictionary parseDictionary) {
    List<Tag> childrenJVMS = tagEliminateAllocation.getNamedChildren(TAG_JVMS);
    String typeID = tagEliminateAllocation.getAttributes().get(ATTR_TYPE);
    String typeOrKlassName = null;
    if (typeID != null) {
        typeOrKlassName = ParseUtil.lookupType(typeID, parseDictionary);
        if (typeOrKlassName != null) {
            for (Tag tagJVMS : childrenJVMS) {
                Map<String, String> tagJVMSAttributes = tagJVMS.getAttributes();
                String attrBCI = tagJVMSAttributes.get(ATTR_BCI);
                int bciValue = 0;
                if (attrBCI != null) {
                    try {
                        bciValue = Integer.parseInt(attrBCI);
                    } catch (NumberFormatException nfe) {
                        logger.error("Couldn't parse bci attribute {} tag {}", attrBCI, tagJVMS.toString(true));
                        continue;
                    }
                } else {
                    logger.error("Missing bci attribute on tag {}", tagJVMS.toString(true));
                }
                String methodID = tagJVMSAttributes.get(ATTR_METHOD);
                BCIOpcodeMap bciOpcodeMap = parseDictionary.getBCIOpcodeMap(methodID);
                //logger.info("method {} {} {}", methodID, parseDictionary.getParseMethod(), bciOpcodeMap.entrySet());
                if (CompilationUtil.memberMatchesMethodID(currentMember, methodID, parseDictionary)) {
                    storeEliminatedAllocation(currentMember, bciValue, typeOrKlassName, bciOpcodeMap);
                } else if (processAnnotationsForInlinedMethods) {
                    IMetaMember inlinedMember = findMemberForInlinedMethod(tagJVMS, parseDictionary);
                    if (inlinedMember != null) {
                        storeEliminatedAllocation(inlinedMember, bciValue, typeOrKlassName, bciOpcodeMap);
                    } else {
                        unhandledTags.add(tagJVMS);
                    }
                }
            }
        } else {
            logger.error("Unknown type attribute {} on tag {}", typeID, tagEliminateAllocation.toString(true));
        }
    } else {
        logger.error("Missing type attribute on tag {}", tagEliminateAllocation.toString(true));
    }
}

================= OUTPUT FORMAT =================


Return the result strictly using the format below:
<refactored code>
[The code after the refactoring should be between these tags.]
</refactored code>
<refactoring explanation>
[The explanation of the refactoring should be between these tags.]
</refactoring explanation>