You are an expert in refactoring code snippets. Here are some examples of refactoring using the Extract Method technique.

================= EXAMPLES =================

Example 1:

Refactoring Description: Extract Method private openReportParamsDialog(report Report, window Window) : void extracted from public createRunReportButton(captionId String, window Window) : AbstractAction in class com.haulmont.cuba.web.app.ui.report.ReportHelper

Code Before:
------------
@@ -46,14 +46,18 @@ private ReportHelper() {
     public static void runReport(Report report, Window window) {
         if (report != null) {
             if (report.getInputParameters() != null && report.getInputParameters().size() > 0) {
-                window.openWindow("report$inputParameters", WindowManager.OpenType.DIALOG,
-                        Collections.<String, Object>singletonMap("report", report));
             } else {
                 ReportHelper.printReport(report, Collections.<String, Object>emptyMap());
             }
         }
     }
 
     public static void runReport(Report report, Window window, final String paramAlias, final Object paramValue) {
         runReport(report, window, paramAlias, paramValue, null);
     }
@@ -62,8 +66,7 @@ public static void runReport(Report report, Window window, final String paramAli
         if (report != null) {
             List<ReportInputParameter> params = report.getInputParameters();
             if (params != null && params.size() > 1) {
-                window.openWindow("report$inputParameters", WindowManager.OpenType.DIALOG,
-                        Collections.<String, Object>singletonMap("report", report));
             } else {
                 if (params != null && params.size() == 1) {
                     if (name == null)
@@ -97,14 +100,6 @@ public static void printReport(Report report, String name, Map<String, Object> p
         }
         if (find)
             printReport(report, name, params, item.getKey(), item.getValue());
-        /*
-        if (ReportOutputType.XLS.equals(reportOutputType))
-            printReport(report, params, ReportOutputType.XLS, ExportFormat.XLS);
-        else if (ReportOutputType.DOC.equals(reportOutputType))
-            printReport(report, params, ReportOutputType.DOC, ExportFormat.DOC);
-        else if (ReportOutputType.PDF.equals(reportOutputType))
-            printReport(report, params, ReportOutputType.PDF, ExportFormat.PDF);
-        */
     }
 
     private static void printReport(Report report, String name, Map<String, Object> params, ReportOutputType reportOutputType, ExportFormat exportFormat) {
@@ -131,7 +126,7 @@ public void handleLookup(Collection items) {
                             report = window.getDsContext().getDataService().reload(report, "report.edit");
                             if (report != null) {
                                 if (report.getInputParameters() != null && report.getInputParameters().size() > 0) {
-                                    window.openWindow("report$inputParameters", WindowManager.OpenType.DIALOG, Collections.<String, Object>singletonMap("report", report));
                                 } else {
                                     ReportHelper.printReport(report, Collections.<String, Object>emptyMap());
                                 }

Code After:
------------
@@ -46,14 +46,18 @@ private ReportHelper() {
     public static void runReport(Report report, Window window) {
         if (report != null) {
             if (report.getInputParameters() != null && report.getInputParameters().size() > 0) {
+                openReportParamsDialog(report, window);
             } else {
                 ReportHelper.printReport(report, Collections.<String, Object>emptyMap());
             }
         }
     }
 
+    private static void openReportParamsDialog(Report report, Window window) {
+        window.openWindow("report$inputParameters", WindowManager.OpenType.DIALOG,
+                Collections.<String, Object>singletonMap("report", report));
+    }
+
     public static void runReport(Report report, Window window, final String paramAlias, final Object paramValue) {
         runReport(report, window, paramAlias, paramValue, null);
     }
@@ -62,8 +66,7 @@ public static void runReport(Report report, Window window, final String paramAli
         if (report != null) {
             List<ReportInputParameter> params = report.getInputParameters();
             if (params != null && params.size() > 1) {
+                openReportParamsDialog(report, window);
             } else {
                 if (params != null && params.size() == 1) {
                     if (name == null)
@@ -97,14 +100,6 @@ public static void printReport(Report report, String name, Map<String, Object> p
         }
         if (find)
             printReport(report, name, params, item.getKey(), item.getValue());
     }
 
     private static void printReport(Report report, String name, Map<String, Object> params, ReportOutputType reportOutputType, ExportFormat exportFormat) {
@@ -131,7 +126,7 @@ public void handleLookup(Collection items) {
                             report = window.getDsContext().getDataService().reload(report, "report.edit");
                             if (report != null) {
                                 if (report.getInputParameters() != null && report.getInputParameters().size() > 0) {
+                                    openReportParamsDialog(report, window);
                                 } else {
                                     ReportHelper.printReport(report, Collections.<String, Object>emptyMap());
                                 }

Example 2:

Refactoring Description: Extract Method private read(sstable SSTableReader, file FileDataInput) : void extracted from public SSTableNamesIterator(sstable SSTableReader, file FileDataInput, key DecoratedKey, columnNames SortedSet<byte[]>) in class org.apache.cassandra.db.columniterator.SSTableNamesIterator

Code Before:
------------
@@ -46,85 +46,91 @@ public class SSTableNamesIterator extends SimpleAbstractColumnIterator implement
     private ColumnFamily cf;
     private Iterator<IColumn> iter;
     public final SortedSet<byte[]> columns;
-    public final DecoratedKey decoratedKey;
 
-    public SSTableNamesIterator(SSTableReader ssTable, DecoratedKey key, SortedSet<byte[]> columnNames)
     {
-        this (ssTable, null, key, columnNames);
-    }
 
-    public SSTableNamesIterator(SSTableReader sstable, FileDataInput file, DecoratedKey key, SortedSet<byte[]> columnNames)
-    {
-        boolean closeFileWhenDone = file == null;
-        
         try
         {
-            assert columnNames != null;
-
-            this.columns = columnNames;
-            this.decoratedKey = key;
-
-            // open the sstable file, if we don't have one passed to use from range scan
-            if (file == null)
             {
-                file = sstable.getFileDataInput(decoratedKey, DatabaseDescriptor.getIndexedReadBufferSizeInKB() * 1024);
-                if (file == null)
-                    return;
-                DecoratedKey keyInDisk = SSTableReader.decodeKey(sstable.getPartitioner(),
-                                                                 sstable.getDescriptor(),
-                                                                 FBUtilities.readShortByteArray(file));
-                assert keyInDisk.equals(decoratedKey)
-                       : String.format("%s != %s in %s", keyInDisk, decoratedKey, file.getPath());
-                SSTableReader.readRowSize(file, sstable.getDescriptor());
             }
-
-            // read the requested columns into `cf`
-            /* Read the bloom filter summarizing the columns */
-            BloomFilter bf = IndexHelper.defreezeBloomFilter(file);
-            List<IndexHelper.IndexInfo> indexList = IndexHelper.deserializeIndex(file);
-
-            // we can stop early if bloom filter says none of the columns actually exist -- but,
-            // we can't stop before initializing the cf above, in case there's a relevant tombstone
-            cf = ColumnFamily.serializer().deserializeFromSSTableNoColumns(sstable.createColumnFamily(), file);
-
-            List<byte[]> filteredColumnNames1 = new ArrayList<byte[]>(columnNames.size());
-            for (byte[] name : columnNames)
             {
-                if (bf.isPresent(name))
-                {
-                    filteredColumnNames1.add(name);
-                }
             }
-            List<byte[]> filteredColumnNames = filteredColumnNames1;
-            if (filteredColumnNames.isEmpty())
-                return;
 
-            if (indexList == null)
-                readSimpleColumns(file, columnNames, filteredColumnNames);
-            else
-                readIndexedColumns(sstable, file, columnNames, filteredColumnNames, indexList);
 
-            // create an iterator view of the columns we read
-            iter = cf.getSortedColumns().iterator();
         }
         catch (IOException ioe)
         {
             throw new IOError(ioe);
         }
-        finally
         {
-            if (closeFileWhenDone && file != null)
             {
-                try
-                {
-                    file.close();
-                }
-                catch (IOException ioe)
-                {
-                    logger.warn("error closing " + file.getPath());
-                }
             }
         }
     }
 
     private void readSimpleColumns(FileDataInput file, SortedSet<byte[]> columnNames, List<byte[]> filteredColumnNames) throws IOException
@@ -183,7 +189,7 @@ private void readIndexedColumns(SSTableReader sstable, FileDataInput file, Sorte
 
     public DecoratedKey getKey()
     {
-        return decoratedKey;
     }
 
     public ColumnFamily getColumnFamily()

Code After:
------------
@@ -46,85 +46,91 @@ public class SSTableNamesIterator extends SimpleAbstractColumnIterator implement
     private ColumnFamily cf;
     private Iterator<IColumn> iter;
     public final SortedSet<byte[]> columns;
+    public final DecoratedKey key;
 
+    public SSTableNamesIterator(SSTableReader sstable, DecoratedKey key, SortedSet<byte[]> columns)
     {
+        assert columns != null;
+        this.columns = columns;
+        this.key = key;
+
+        FileDataInput file = sstable.getFileDataInput(key, DatabaseDescriptor.getIndexedReadBufferSizeInKB() * 1024);
+        if (file == null)
+            return;
 
         try
         {
+            DecoratedKey keyInDisk = SSTableReader.decodeKey(sstable.getPartitioner(),
+                                                             sstable.getDescriptor(),
+                                                             FBUtilities.readShortByteArray(file));
+            assert keyInDisk.equals(key) : String.format("%s != %s in %s", keyInDisk, key, file.getPath());
+            SSTableReader.readRowSize(file, sstable.getDescriptor());
+            read(sstable, file);
+        }
+        catch (IOException e)
+        {
+            throw new IOError(e);
+        }
+        finally
+        {
+            try
             {
+                file.close();
             }
+            catch (IOException ioe)
             {
+                logger.warn("error closing " + file.getPath());
             }
+        }
+    }
 
+    public SSTableNamesIterator(SSTableReader sstable, FileDataInput file, DecoratedKey key, SortedSet<byte[]> columns)
+    {
+        assert columns != null;
+        this.columns = columns;
+        this.key = key;
 
+        try
+        {
+            read(sstable, file);
         }
         catch (IOException ioe)
         {
             throw new IOError(ioe);
         }
+    }
+
+    private void read(SSTableReader sstable, FileDataInput file)
+    throws IOException
+    {
+
+        // read the requested columns into `cf`
+        /* Read the bloom filter summarizing the columns */
+        BloomFilter bf = IndexHelper.defreezeBloomFilter(file);
+        List<IndexHelper.IndexInfo> indexList = IndexHelper.deserializeIndex(file);
+
+        // we can stop early if bloom filter says none of the columns actually exist -- but,
+        // we can't stop before initializing the cf above, in case there's a relevant tombstone
+        cf = ColumnFamily.serializer().deserializeFromSSTableNoColumns(sstable.createColumnFamily(), file);
+
+        List<byte[]> filteredColumnNames = new ArrayList<byte[]>(columns.size());
+        for (byte[] name : columns)
         {
+            if (bf.isPresent(name))
             {
+                filteredColumnNames.add(name);
             }
         }
+        if (filteredColumnNames.isEmpty())
+            return;
+
+        if (indexList == null)
+            readSimpleColumns(file, columns, filteredColumnNames);
+        else
+            readIndexedColumns(sstable, file, columns, filteredColumnNames, indexList);
+
+        // create an iterator view of the columns we read
+        iter = cf.getSortedColumns().iterator();
     }
 
     private void readSimpleColumns(FileDataInput file, SortedSet<byte[]> columnNames, List<byte[]> filteredColumnNames) throws IOException
@@ -183,7 +189,7 @@ private void readIndexedColumns(SSTableReader sstable, FileDataInput file, Sorte
 
     public DecoratedKey getKey()
     {
+        return key;
     }
 
     public ColumnFamily getColumnFamily()

Example 3:

Refactoring Description: Extract Method private makePayloadDataAvailable() : void extracted from public read(b byte[], off int, len int) : int in class org.apache.catalina.websocket.WsInputStream

Code Before:
------------
@@ -67,31 +67,8 @@ private void processFrame() throws IOException {
 
     @Override
     public int read() throws IOException {
-        if (error != null) {
-            throw new IOException(error);
-        }
-        while (remaining == 0 && !getFrame().getFin()) {
-            // Need more data - process next frame
-            processFrame();
-            while (frame.isControl()) {
-                if (getFrame().getOpCode() == Constants.OPCODE_PING) {
-                    outbound.pong(frame.getPayLoad());
-                } else if (getFrame().getOpCode() == Constants.OPCODE_PONG) {
-                    // NO-OP. Swallow it.
-                } else if (getFrame().getOpCode() == Constants.OPCODE_CLOSE) {
-                    outbound.close(frame);
-                } else{
-                    throw new IOException(sm.getString("is.unknownOpCode",
-                            Byte.valueOf(getFrame().getOpCode())));
-                }
-                processFrame();
-            }
-            if (getFrame().getOpCode() != Constants.OPCODE_CONTINUATION) {
-                error = sm.getString("is.notContinutation",
-                        Byte.valueOf(getFrame().getOpCode()));
-                throw new IOException(error);
-            }
-        }
 
         if (remaining == 0) {
             return -1;
@@ -111,6 +88,35 @@ public int read() throws IOException {
 
     @Override
     public int read(byte b[], int off, int len) throws IOException {
         if (error != null) {
             throw new IOException(error);
         }
@@ -136,26 +142,5 @@ public int read(byte b[], int off, int len) throws IOException {
                 throw new IOException(error);
             }
         }
-
-        if (remaining == 0) {
-            return -1;
-        }
-
-        if (len > remaining) {
-            len = (int) remaining;
-        }
-        int result = processor.read(b, off, len);
-        if(result == -1) {
-            return -1;
-        }
-
-        for (int i = off; i < off + result; i++) {
-            b[i] = (byte) (b[i] ^
-                    frame.getMask()[(int) ((readThisFragment + i - off) % 4)]);
-        }
-        remaining -= result;
-        readThisFragment += result;
-        return result;
     }
-
 }

Code After:
------------
@@ -67,31 +67,8 @@ private void processFrame() throws IOException {
 
     @Override
     public int read() throws IOException {
+
+        makePayloadDataAvailable();
 
         if (remaining == 0) {
             return -1;
@@ -111,6 +88,35 @@ public int read() throws IOException {
 
     @Override
     public int read(byte b[], int off, int len) throws IOException {
+
+        makePayloadDataAvailable();
+
+        if (remaining == 0) {
+            return -1;
+        }
+
+        if (len > remaining) {
+            len = (int) remaining;
+        }
+        int result = processor.read(b, off, len);
+        if(result == -1) {
+            return -1;
+        }
+
+        for (int i = off; i < off + result; i++) {
+            b[i] = (byte) (b[i] ^
+                    frame.getMask()[(int) ((readThisFragment + i - off) % 4)]);
+        }
+        remaining -= result;
+        readThisFragment += result;
+        return result;
+    }
+
+
+    /*
+     * Ensures that there is payload data ready to read.
+     */
+    private void makePayloadDataAvailable() throws IOException {
         if (error != null) {
             throw new IOException(error);
         }
@@ -136,26 +142,5 @@ public int read(byte b[], int off, int len) throws IOException {
                 throw new IOException(error);
             }
         }
     }
 }

================= REFACTORING MECHANICS =================

Please provide a refactored version of the code snippets above using the Extract Method technique, following these mechanics: 

1. Find a piece of code that does one clear task.
2. Note what variables it uses or changes.
3. Create a new method with a clear name.
4. Move the piece there, adding needed parameters and returns.
5. Replace the old chunk with a call to the new method.
6. Compile and Test to confirm it works the same.

================= CODE TO REFACTOR =================

/**
 * Returns the number of characters between the current position and the next instance of the input sequence
 *
 * @param seq scan target
 * @return offset between current position and next instance of target. -1 if not found.
 */
int nextIndexOf(CharSequence seq) {
    bufferUp();
    // doesn't handle scanning for surrogates
    char startChar = seq.charAt(0);
    for (int offset = bufPos; offset < bufLength; offset++) {
        // scan to first instance of startchar:
        if (startChar != charBuf[offset])
            while (++offset < bufLength && startChar != charBuf[offset]) {
                /* empty */
            }
        int i = offset + 1;
        int last = i + seq.length() - 1;
        if (offset < bufLength && last <= bufLength) {
            for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) {
                /* empty */
            }
            if (// found full sequence
            i == last)
                return offset - bufPos;
        }
    }
    return -1;
}

================= OUTPUT FORMAT =================


Return the result strictly using the format below:
<refactored code>
[The code after the refactoring should be between these tags.]
</refactored code>
<refactoring explanation>
[The explanation of the refactoring should be between these tags.]
</refactoring explanation>