You are an expert in refactoring code snippets. Here are some examples of refactoring using the Extract Method technique.

================= EXAMPLES =================

Example 1:

Refactoring Description: Extract Method private createContextMarker() : void extracted from public initLayer(view OsmandMapTileView) : void in class net.osmand.plus.views.layers.MapQuickActionLayer

Code Before:
------------
@@ -78,7 +78,10 @@ public MapQuickActionLayer(@NonNull Context context) {
 	@Override
 	public void initLayer(@NonNull OsmandMapTileView view) {
 		super.initLayer(view);
 
 		Context context = AndroidUtils.createDisplayContext(getContext());
 		contextMarker = new ImageView(context);
 		contextMarker.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT));
@@ -89,6 +92,12 @@ public void initLayer(@NonNull OsmandMapTileView view) {
 		contextMarker.layout(0, 0, width, height);
 	}
 
 	@SuppressLint("ClickableViewAccessibility")
 	@Override
 	public void setMapActivity(@Nullable MapActivity mapActivity) {

Code After:
------------
@@ -78,7 +78,10 @@ public MapQuickActionLayer(@NonNull Context context) {
 	@Override
 	public void initLayer(@NonNull OsmandMapTileView view) {
 		super.initLayer(view);
+		createContextMarker();
+	}
 
+	private void createContextMarker() {
 		Context context = AndroidUtils.createDisplayContext(getContext());
 		contextMarker = new ImageView(context);
 		contextMarker.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT));
@@ -89,6 +92,12 @@ public void initLayer(@NonNull OsmandMapTileView view) {
 		contextMarker.layout(0, 0, width, height);
 	}
 
+	@Override
+	protected void updateResources() {
+		super.updateResources();
+		createContextMarker();
+	}
+
 	@SuppressLint("ClickableViewAccessibility")
 	@Override
 	public void setMapActivity(@Nullable MapActivity mapActivity) {

Example 2:

Refactoring Description: Extract Method public hasAmmo(tile Tile) : boolean extracted from public update(tile Tile) : void in class io.anuke.mindustry.world.blocks.types.defense.Turret

Code Before:
------------
@@ -35,7 +35,7 @@ public class Turret extends Block{
 	protected int ammoMultiplier = 20;
 	protected int maxammo = 400;
 	protected float rotatespeed = 0.2f;
-	protected float shootCone = 2f;
 
 	public Turret(String name) {
 		super(name);
@@ -112,7 +112,7 @@ public void update(Tile tile){
 		if(entity.target != null && entity.target.isDead())
 			entity.target = null;
 		
-		if(entity.ammo > 0){
 			
 			if(Timers.get(entity, "target", targetInterval)){
 				entity.target = (Enemy)Entities.getClosest(tile.worldx(), tile.worldy(), range, e->{
@@ -132,12 +132,23 @@ public void update(Tile tile){
 				if(Angles.angleDist(entity.rotation, targetRot) < shootCone && Timers.get(tile, "reload", reload)){
 					Effects.sound(shootsound, entity);
 					shoot(tile);
 					entity.ammo --;
 				}
 			}
 		}
 	}
 	
 	@Override
 	public TileEntity getEntity(){
 		return new TurretEntity();

Code After:
------------
@@ -35,7 +35,7 @@ public class Turret extends Block{
 	protected int ammoMultiplier = 20;
 	protected int maxammo = 400;
 	protected float rotatespeed = 0.2f;
+	protected float shootCone = 5f;
 
 	public Turret(String name) {
 		super(name);
@@ -112,7 +112,7 @@ public void update(Tile tile){
 		if(entity.target != null && entity.target.isDead())
 			entity.target = null;
 		
+		if(hasAmmo(tile)){
 			
 			if(Timers.get(entity, "target", targetInterval)){
 				entity.target = (Enemy)Entities.getClosest(tile.worldx(), tile.worldy(), range, e->{
@@ -132,12 +132,23 @@ public void update(Tile tile){
 				if(Angles.angleDist(entity.rotation, targetRot) < shootCone && Timers.get(tile, "reload", reload)){
 					Effects.sound(shootsound, entity);
 					shoot(tile);
+					consumeAmmo(tile);
 					entity.ammo --;
 				}
 			}
 		}
 	}
 	
+	public boolean hasAmmo(Tile tile){
+		TurretEntity entity = tile.entity();
+		return entity.ammo > 0;
+	}
+	
+	public void consumeAmmo(Tile tile){
+		TurretEntity entity = tile.entity();
+		entity.ammo --;
+	}
+	
 	@Override
 	public TileEntity getEntity(){
 		return new TurretEntity();

Example 3:

Refactoring Description: Extract Method private checkDelete(payload Object) : void extracted from public poll(requestMessage Message<?>) : Object in class org.springframework.integration.jpa.core.JpaExecutor

Code Before:
------------
@@ -472,6 +472,7 @@ else if (this.namedQuery != null) {
 	 * Execute the JPA operation. Delegates to {@link JpaExecutor#poll(Message)}.
 	 * @return The object or null.
 	 */
 	public Object poll() {
 		return poll(null);
 	}
@@ -485,6 +486,7 @@ public Object poll() {
 	 * @param requestMessage May be null.
 	 * @return The payload object, which may be null.
 	 */
 	public Object poll(@Nullable final Message<?> requestMessage) {
 		final Object payload;
 
@@ -508,8 +510,8 @@ public Object poll(@Nullable final Message<?> requestMessage) {
 				if (this.firstResultExpression != null) {
 					firstResult = getFirstResult(requestMessage);
 				}
-				ParameterSource parameterSource = determineParameterSource(requestMessage);
-				result = doPoll(parameterSource, firstResult, maxNumberOfResults);
 			}
 
 			if (result.isEmpty()) {
@@ -535,6 +537,11 @@ else if (requestMessage != null) {
 			}
 		}
 
 		if (payload != null && this.deleteAfterPoll) {
 			if (payload instanceof Iterable) {
 				if (this.deleteInBatch) {
@@ -554,7 +561,6 @@ else if (requestMessage != null) {
 				this.jpaOperations.flush();
 			}
 		}
-		return payload;
 	}
 
 	protected List<?> doPoll(ParameterSource jpaQLParameterSource, int firstResult, int maxNumberOfResults) {

Code After:
------------
@@ -472,6 +472,7 @@ else if (this.namedQuery != null) {
 	 * Execute the JPA operation. Delegates to {@link JpaExecutor#poll(Message)}.
 	 * @return The object or null.
 	 */
+	@Nullable
 	public Object poll() {
 		return poll(null);
 	}
@@ -485,6 +486,7 @@ public Object poll() {
 	 * @param requestMessage May be null.
 	 * @return The payload object, which may be null.
 	 */
+	@Nullable
 	public Object poll(@Nullable final Message<?> requestMessage) {
 		final Object payload;
 
@@ -508,8 +510,8 @@ public Object poll(@Nullable final Message<?> requestMessage) {
 				if (this.firstResultExpression != null) {
 					firstResult = getFirstResult(requestMessage);
 				}
+				ParameterSource paramSource = determineParameterSource(requestMessage);
+				result = doPoll(paramSource, firstResult, maxNumberOfResults);
 			}
 
 			if (result.isEmpty()) {
@@ -535,6 +537,11 @@ else if (requestMessage != null) {
 			}
 		}
 
+		checkDelete(payload);
+		return payload;
+	}
+
+	private void checkDelete(final Object payload) {
 		if (payload != null && this.deleteAfterPoll) {
 			if (payload instanceof Iterable) {
 				if (this.deleteInBatch) {
@@ -554,7 +561,6 @@ else if (requestMessage != null) {
 				this.jpaOperations.flush();
 			}
 		}
 	}
 
 	protected List<?> doPoll(ParameterSource jpaQLParameterSource, int firstResult, int maxNumberOfResults) {

================= REFACTORING MECHANICS =================

Please provide a refactored version of the code snippets above using the Extract Method technique, following these mechanics: 

1. Find a piece of code that does one clear task.
2. Note what variables it uses or changes.
3. Create a new method with a clear name.
4. Move the piece there, adding needed parameters and returns.
5. Replace the old chunk with a call to the new method.
6. Compile and Test to confirm it works the same.

================= CODE TO REFACTOR =================

/**
 * Encode the given symbol info to a bit matrix.
 *
 * @param placement  The DataMatrix placement.
 * @param symbolInfo The symbol info to encode.
 * @return The bit matrix generated.
 */
private static BitMatrix encodeLowLevel(DefaultPlacement placement, SymbolInfo symbolInfo, int width, int height) {
    int symbolWidth = symbolInfo.getSymbolDataWidth();
    int symbolHeight = symbolInfo.getSymbolDataHeight();
    ByteMatrix matrix = new ByteMatrix(symbolInfo.getSymbolWidth(), symbolInfo.getSymbolHeight());
    int matrixY = 0;
    for (int y = 0; y < symbolHeight; y++) {
        // Fill the top edge with alternate 0 / 1
        int matrixX;
        if ((y % symbolInfo.matrixHeight) == 0) {
            matrixX = 0;
            for (int x = 0; x < symbolInfo.getSymbolWidth(); x++) {
                matrix.set(matrixX, matrixY, (x % 2) == 0);
                matrixX++;
            }
            matrixY++;
        }
        matrixX = 0;
        for (int x = 0; x < symbolWidth; x++) {
            // Fill the right edge with full 1
            if ((x % symbolInfo.matrixWidth) == 0) {
                matrix.set(matrixX, matrixY, true);
                matrixX++;
            }
            matrix.set(matrixX, matrixY, placement.getBit(x, y));
            matrixX++;
            // Fill the right edge with alternate 0 / 1
            if ((x % symbolInfo.matrixWidth) == symbolInfo.matrixWidth - 1) {
                matrix.set(matrixX, matrixY, (y % 2) == 0);
                matrixX++;
            }
        }
        matrixY++;
        // Fill the bottom edge with full 1
        if ((y % symbolInfo.matrixHeight) == symbolInfo.matrixHeight - 1) {
            matrixX = 0;
            for (int x = 0; x < symbolInfo.getSymbolWidth(); x++) {
                matrix.set(matrixX, matrixY, true);
                matrixX++;
            }
            matrixY++;
        }
    }
    return convertByteMatrixToBitMatrix(matrix, width, height);
}

================= OUTPUT FORMAT =================


Return the result strictly using the format below:
<refactored code>
[The code after the refactoring should be between these tags.]
</refactored code>
<refactoring explanation>
[The explanation of the refactoring should be between these tags.]
</refactoring explanation>