You are an expert in refactoring code snippets. Here are some examples of refactoring using the Extract Method technique.

================= EXAMPLES =================

Example 1:

Refactoring Description: Extract Method private isEmpty(uri Uri) : boolean extracted from public openForWrite(uri Uri, append boolean) : OutputStream in class cgeo.geocaching.storage.ContentStorage

Code Before:
------------
@@ -184,7 +184,7 @@ public Uri create(final Folder folder, final FileNameCreator nameCreator, final
     }
      /** Deletes the file represented by given Uri */
     public boolean delete(final Uri uri) {
-        if (uri == null) {
             return false;
         }
         try {
@@ -312,7 +312,7 @@ public String getName(final Uri uri) {
      * Unfortunately it is not possible to retrieve this info from an Uri alone.
      * */
     public FileInformation getFileInfo(final Uri uri) {
-        if (uri == null) {
             return null;
         }
 
@@ -331,7 +331,7 @@ public OutputStream openForWrite(final Uri uri) {
     }
 
     public OutputStream openForWrite(final Uri uri, final boolean append) {
-        if (uri == null) {
             return null;
         }
 
@@ -375,7 +375,7 @@ public InputStream openForRead(final Uri uri) {
      * @param suppressWarningForUser if true then failure to open will NOT result in a toast to user
      */
     public InputStream openForRead(final Uri uri, final boolean suppressWarningForUser) {
-        if (uri == null) {
             return null;
         }
 
@@ -580,4 +580,8 @@ private void reportProblem(@StringRes final int messageId, final Exception ex, f
         }
         reportRunningFlag.set(false);
     }
 }

Code After:
------------
@@ -184,7 +184,7 @@ public Uri create(final Folder folder, final FileNameCreator nameCreator, final
     }
      /** Deletes the file represented by given Uri */
     public boolean delete(final Uri uri) {
+        if (isEmpty(uri)) {
             return false;
         }
         try {
@@ -312,7 +312,7 @@ public String getName(final Uri uri) {
      * Unfortunately it is not possible to retrieve this info from an Uri alone.
      * */
     public FileInformation getFileInfo(final Uri uri) {
+        if (isEmpty(uri)) {
             return null;
         }
 
@@ -331,7 +331,7 @@ public OutputStream openForWrite(final Uri uri) {
     }
 
     public OutputStream openForWrite(final Uri uri, final boolean append) {
+        if (isEmpty(uri)) {
             return null;
         }
 
@@ -375,7 +375,7 @@ public InputStream openForRead(final Uri uri) {
      * @param suppressWarningForUser if true then failure to open will NOT result in a toast to user
      */
     public InputStream openForRead(final Uri uri, final boolean suppressWarningForUser) {
+        if (isEmpty(uri)) {
             return null;
         }
 
@@ -580,4 +580,8 @@ private void reportProblem(@StringRes final int messageId, final Exception ex, f
         }
         reportRunningFlag.set(false);
     }
+
+    private static boolean isEmpty(final Uri uri) {
+        return uri == null || uri.equals(Uri.EMPTY);
+    }
 }

Example 2:

Refactoring Description: Extract Method public CreateAnalyzeJobStmt(tbl TableName, columnNames List<String>, isSample boolean, properties Map<String,String>, pos NodePosition) extracted from public CreateAnalyzeJobStmt(tbl TableName, columnNames List<String>, isSample boolean, properties Map<String,String>) in class com.starrocks.sql.ast.CreateAnalyzeJobStmt

Code Before:
------------
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.Lists;
 import com.starrocks.analysis.TableName;
 import com.starrocks.statistic.StatsConstants;
 
 import java.util.List;
@@ -31,15 +32,20 @@ public class CreateAnalyzeJobStmt extends DdlStmt {
     private Map<String, String> properties;
 
     public CreateAnalyzeJobStmt(boolean isSample, Map<String, String> properties) {
-        this(null, Lists.newArrayList(), isSample, properties);
     }
 
     public CreateAnalyzeJobStmt(String db, boolean isSample, Map<String, String> properties) {
-        this(new TableName(db, null), Lists.newArrayList(), isSample, properties);
     }
 
     public CreateAnalyzeJobStmt(TableName tbl, List<String> columnNames, boolean isSample,
                                 Map<String, String> properties) {
         this.tbl = tbl;
         this.dbId = StatsConstants.DEFAULT_ALL_ID;
         this.tableId = StatsConstants.DEFAULT_ALL_ID;

Code After:
------------
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.Lists;
 import com.starrocks.analysis.TableName;
+import com.starrocks.sql.parser.NodePosition;
 import com.starrocks.statistic.StatsConstants;
 
 import java.util.List;
@@ -31,15 +32,20 @@ public class CreateAnalyzeJobStmt extends DdlStmt {
     private Map<String, String> properties;
 
     public CreateAnalyzeJobStmt(boolean isSample, Map<String, String> properties) {
+        this(null, Lists.newArrayList(), isSample, properties, NodePosition.ZERO);
     }
 
     public CreateAnalyzeJobStmt(String db, boolean isSample, Map<String, String> properties) {
+        this(new TableName(db, null), Lists.newArrayList(), isSample, properties, NodePosition.ZERO);
     }
 
     public CreateAnalyzeJobStmt(TableName tbl, List<String> columnNames, boolean isSample,
                                 Map<String, String> properties) {
+        this(tbl, columnNames, isSample, properties, NodePosition.ZERO);
+    }
+    public CreateAnalyzeJobStmt(TableName tbl, List<String> columnNames, boolean isSample,
+                                Map<String, String> properties, NodePosition pos) {
+        super(pos);
         this.tbl = tbl;
         this.dbId = StatsConstants.DEFAULT_ALL_ID;
         this.tableId = StatsConstants.DEFAULT_ALL_ID;

Example 3:

Refactoring Description: Extract Method private checkOnCollisionsSSK(useSlotFilter boolean) : void extracted from public testOnCollisionsSSK() : void in class freenet.store.CachingFreenetStoreTest

Code Before:
------------
@@ -352,9 +352,16 @@ public void testTimeExpireSSK() throws IOException, SSKEncodeException, InvalidC
 		
 		cachingStore.close();
 	}
 	
 	/* Test collisions on SSK */
-	public void testOnCollisionsSSK() throws IOException, SSKEncodeException, InvalidCompressionCodecException, SSKVerifyException, KeyDecodeException, KeyCollisionException {
 		File f = new File(tempDir, "saltstore");
 		FileUtil.removeAll(f);
 
@@ -363,7 +370,7 @@ public void testOnCollisionsSSK() throws IOException, SSKEncodeException, Invali
 		new RAMFreenetStore<DSAPublicKey>(pk, keys);
 		GetPubkey pubkeyCache = new SimpleGetPubkey(pk);
 		SSKStore store = new SSKStore(pubkeyCache);
-		SaltedHashFreenetStore<SSKBlock> saltStore = SaltedHashFreenetStore.construct(f, "testCachingFreenetStoreOnCloseSSK", store, weakPRNG, 10, false, SemiOrderedShutdownHook.get(), true, true, ticker, null);
 		CachingFreenetStore<SSKBlock> cachingStore = new CachingFreenetStore<SSKBlock>(store, cachingFreenetStoreMaxSize, cachingFreenetStorePeriod, saltStore, ticker);
 		cachingStore.start(null, true);
 		RandomSource random = new DummyRandomSource(12345);

Code After:
------------
@@ -352,9 +352,16 @@ public void testTimeExpireSSK() throws IOException, SSKEncodeException, InvalidC
 		
 		cachingStore.close();
 	}
+
+	public void testOnCollisionsSSK() throws IOException, SSKEncodeException, InvalidCompressionCodecException, SSKVerifyException, KeyDecodeException, KeyCollisionException {
+		// With slot filters turned off, it goes straight to disk, because probablyInStore() always returns true.
+		checkOnCollisionsSSK(false);
+		// With slot filters turned on, it should be cached, it should compare it, and still not throw if it's the same block.
+		checkOnCollisionsSSK(true);
+	}
 	
 	/* Test collisions on SSK */
+	private void checkOnCollisionsSSK(boolean useSlotFilter) throws IOException, SSKEncodeException, InvalidCompressionCodecException, SSKVerifyException, KeyDecodeException, KeyCollisionException {
 		File f = new File(tempDir, "saltstore");
 		FileUtil.removeAll(f);
 
@@ -363,7 +370,7 @@ public void testOnCollisionsSSK() throws IOException, SSKEncodeException, Invali
 		new RAMFreenetStore<DSAPublicKey>(pk, keys);
 		GetPubkey pubkeyCache = new SimpleGetPubkey(pk);
 		SSKStore store = new SSKStore(pubkeyCache);
+		SaltedHashFreenetStore<SSKBlock> saltStore = SaltedHashFreenetStore.construct(f, "testCachingFreenetStoreOnCloseSSK", store, weakPRNG, 10, true, SemiOrderedShutdownHook.get(), true, true, ticker, null);
 		CachingFreenetStore<SSKBlock> cachingStore = new CachingFreenetStore<SSKBlock>(store, cachingFreenetStoreMaxSize, cachingFreenetStorePeriod, saltStore, ticker);
 		cachingStore.start(null, true);
 		RandomSource random = new DummyRandomSource(12345);

================= REFACTORING MECHANICS =================

Please provide a refactored version of the code snippets above using the Extract Method technique, following these mechanics: 

1. Find a piece of code that does one clear task.
2. Note what variables it uses or changes.
3. Create a new method with a clear name.
4. Move the piece there, adding needed parameters and returns.
5. Replace the old chunk with a call to the new method.
6. Compile and Test to confirm it works the same.

================= CODE TO REFACTOR =================

private void visitTagEliminateLock(Tag tagEliminateLock, IParseDictionary parseDictionary) {
    String kind = tagEliminateLock.getAttributes().get(ATTR_KIND);
    List<Tag> childrenJVMS = tagEliminateLock.getNamedChildren(TAG_JVMS);
    if (childrenJVMS.size() > 0) {
        for (Tag tagJVMS : childrenJVMS) {
            Map<String, String> tagJVMSAttributes = tagJVMS.getAttributes();
            String attrBCI = tagJVMSAttributes.get(ATTR_BCI);
            int bciValue = 0;
            if (attrBCI != null) {
                try {
                    bciValue = Integer.parseInt(attrBCI);
                } catch (NumberFormatException nfe) {
                    logger.error("Couldn't parse bci attribute {} tag {}", attrBCI, tagJVMS.toString(true));
                    continue;
                }
            } else {
                logger.error("Missing bci attribute on tag {}", tagJVMS.toString(true));
            }
            String methodID = tagJVMSAttributes.get(ATTR_METHOD);
            BCIOpcodeMap bciOpcodeMap = parseDictionary.getBCIOpcodeMap(methodID);
            //logger.info("current {} methodID {} parseMethod {}", currentMember.toStringUnqualifiedMethodName(true, true), methodID, parseDictionary.getParseMethod());
            if (CompilationUtil.memberMatchesMethodID(currentMember, methodID, parseDictionary)) {
                storeElidedLock(currentMember, bciValue, kind, bciOpcodeMap);
            } else if (processAnnotationsForInlinedMethods) {
                IMetaMember inlinedMember = findMemberForInlinedMethod(tagJVMS, parseDictionary);
                if (inlinedMember != null) {
                    storeElidedLock(inlinedMember, bciValue, kind, bciOpcodeMap);
                } else {
                    unhandledTags.add(tagJVMS);
                }
            }
        }
        // end for
    }
}

================= OUTPUT FORMAT =================


Return the result strictly using the format below:
<refactored code>
[The code after the refactoring should be between these tags.]
</refactored code>
<refactoring explanation>
[The explanation of the refactoring should be between these tags.]
</refactoring explanation>