You are an expert in refactoring code snippets. Here are some examples of refactoring using the Extract Method technique.

================= EXAMPLES =================

Example 1:

Refactoring Description: Extract Method private collectSeqFileSize(fileSizes EnumMap<FileSizeConstants,Long>, kinds FileSizeConstants) : long extracted from public getFileSizesInByte() : Map<FileSizeConstants,Long> in class org.apache.iotdb.db.monitor.collector.FileSize

Code Before:
------------
@@ -30,8 +30,8 @@
 import org.apache.commons.io.FileUtils;
 import org.apache.iotdb.db.conf.IoTDBConfig;
 import org.apache.iotdb.db.conf.IoTDBDescriptor;
-import org.apache.iotdb.db.engine.filenode.FileNodeManager;
-import org.apache.iotdb.db.exception.FileNodeManagerException;
 import org.apache.iotdb.db.monitor.IStatistic;
 import org.apache.iotdb.db.monitor.MonitorConstants;
 import org.apache.iotdb.db.monitor.MonitorConstants.FileSizeConstants;
@@ -51,10 +51,10 @@
 public class FileSize implements IStatistic {
 
   private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();
-  private static final Logger LOGGER = LoggerFactory.getLogger(FileSize.class);
   private static final long ABNORMAL_VALUE = -1L;
   private static final long INIT_VALUE_IF_FILE_NOT_EXIST = 0L;
-  private FileNodeManager fileNodeManager;
 
   @Override
   public Map<String, TSRecord> getAllStatisticsValue() {
@@ -77,11 +77,11 @@ public void registerStatMetadata() {
       hashMap.put(seriesPath, MonitorConstants.DATA_TYPE_INT64);
       Path path = new Path(seriesPath);
       try {
-        fileNodeManager.addTimeSeries(path, TSDataType.valueOf(MonitorConstants.DATA_TYPE_INT64),
             TSEncoding.valueOf("RLE"), CompressionType.valueOf(TSFileConfig.compressor),
             Collections.emptyMap());
-      } catch (FileNodeManagerException e) {
-        LOGGER.error("Register File Size Stats into fileNodeManager Failed.", e);
       }
     }
     StatMonitor.getInstance().registerStatStorageGroup(hashMap);
@@ -114,7 +114,7 @@ private static class FileSizeHolder {
   }
 
   private FileSize() {
-    fileNodeManager = FileNodeManager.getInstance();
     if (config.isEnableStatMonitor()) {
       StatMonitor statMonitor = StatMonitor.getInstance();
       registerStatMetadata();
@@ -135,32 +135,17 @@ public static FileSize getInstance() {
   public Map<FileSizeConstants, Long> getFileSizesInByte() {
     EnumMap<FileSizeConstants, Long> fileSizes = new EnumMap<>(FileSizeConstants.class);
     for (FileSizeConstants kinds : MonitorConstants.FileSizeConstants.values()) {
-      if (kinds.equals(MonitorConstants.FileSizeConstants.SETTLED)) {
-        //sum bufferWriteDirs size
-        long settledSize = INIT_VALUE_IF_FILE_NOT_EXIST;
-        for (String bufferWriteDir : config.getBufferWriteDirs()) {
-          File settledFile = new File(bufferWriteDir);
-          if (settledFile.exists()) {
-            try {
-              settledSize += FileUtils.sizeOfDirectory(settledFile);
-            } catch (Exception e) {
-              LOGGER.error("Meet error while trying to get {} size with dir {} .", kinds,
-                  bufferWriteDir, e);
-              fileSizes.put(kinds, ABNORMAL_VALUE);
-            }
-          }
-        }
-        fileSizes.put(kinds, settledSize);
       } else {
         File file = new File(kinds.getPath());
         if (file.exists()) {
           try {
             fileSizes.put(kinds, FileUtils.sizeOfDirectory(file));
           } catch (Exception e) {
-            LOGGER
-                .error("Meet error while trying to get {} size with dir {} .", kinds,
-                    kinds.getPath(),
-                    e);
             fileSizes.put(kinds, ABNORMAL_VALUE);
           }
         } else {
@@ -170,4 +155,24 @@ public Map<FileSizeConstants, Long> getFileSizesInByte() {
     }
     return fileSizes;
   }
 }

Code After:
------------
@@ -30,8 +30,8 @@
 import org.apache.commons.io.FileUtils;
 import org.apache.iotdb.db.conf.IoTDBConfig;
 import org.apache.iotdb.db.conf.IoTDBDescriptor;
+import org.apache.iotdb.db.engine.StorageEngine;
+import org.apache.iotdb.db.exception.StorageEngineException;
 import org.apache.iotdb.db.monitor.IStatistic;
 import org.apache.iotdb.db.monitor.MonitorConstants;
 import org.apache.iotdb.db.monitor.MonitorConstants.FileSizeConstants;
@@ -51,10 +51,10 @@
 public class FileSize implements IStatistic {
 
   private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();
+  private static final Logger logger = LoggerFactory.getLogger(FileSize.class);
   private static final long ABNORMAL_VALUE = -1L;
   private static final long INIT_VALUE_IF_FILE_NOT_EXIST = 0L;
+  private StorageEngine storageEngine;
 
   @Override
   public Map<String, TSRecord> getAllStatisticsValue() {
@@ -77,11 +77,11 @@ public void registerStatMetadata() {
       hashMap.put(seriesPath, MonitorConstants.DATA_TYPE_INT64);
       Path path = new Path(seriesPath);
       try {
+        storageEngine.addTimeSeries(path, TSDataType.valueOf(MonitorConstants.DATA_TYPE_INT64),
             TSEncoding.valueOf("RLE"), CompressionType.valueOf(TSFileConfig.compressor),
             Collections.emptyMap());
+      } catch (StorageEngineException e) {
+        logger.error("Register File Size Stats into storageEngine Failed.", e);
       }
     }
     StatMonitor.getInstance().registerStatStorageGroup(hashMap);
@@ -114,7 +114,7 @@ private static class FileSizeHolder {
   }
 
   private FileSize() {
+    storageEngine = StorageEngine.getInstance();
     if (config.isEnableStatMonitor()) {
       StatMonitor statMonitor = StatMonitor.getInstance();
       registerStatMetadata();
@@ -135,32 +135,17 @@ public static FileSize getInstance() {
   public Map<FileSizeConstants, Long> getFileSizesInByte() {
     EnumMap<FileSizeConstants, Long> fileSizes = new EnumMap<>(FileSizeConstants.class);
     for (FileSizeConstants kinds : MonitorConstants.FileSizeConstants.values()) {
+
+      if (kinds.equals(FileSizeConstants.SYS)) {
+        fileSizes.put(kinds, collectSeqFileSize(fileSizes, kinds));
       } else {
         File file = new File(kinds.getPath());
         if (file.exists()) {
           try {
             fileSizes.put(kinds, FileUtils.sizeOfDirectory(file));
           } catch (Exception e) {
+            logger.error("Meet error while trying to get {} size with dir {} .", kinds,
+                    kinds.getPath(), e);
             fileSizes.put(kinds, ABNORMAL_VALUE);
           }
         } else {
@@ -170,4 +155,24 @@ public Map<FileSizeConstants, Long> getFileSizesInByte() {
     }
     return fileSizes;
   }
+
+  private long collectSeqFileSize(EnumMap<FileSizeConstants, Long> fileSizes, FileSizeConstants kinds) {
+    long fileSize = INIT_VALUE_IF_FILE_NOT_EXIST;
+    for (String sequenceDir : config.getDataDirs()) {
+      if (sequenceDir.contains("unsequence")) {
+        continue;
+      }
+      File settledFile = new File(sequenceDir);
+      if (settledFile.exists()) {
+        try {
+          fileSize += FileUtils.sizeOfDirectory(settledFile);
+        } catch (Exception e) {
+          logger.error("Meet error while trying to get {} size with dir {} .", kinds,
+              sequenceDir, e);
+          fileSizes.put(kinds, ABNORMAL_VALUE);
+        }
+      }
+    }
+    return fileSize;
+  }
 }

Example 2:

Refactoring Description: Extract Method private Cue(text CharSequence, textAlignment Alignment, line float, lineType int, lineAnchor int, position float, positionAnchor int, size float, size_height float, bitmap Bitmap) extracted from public Cue(text CharSequence, textAlignment Alignment, line float, lineType int, lineAnchor int, position float, positionAnchor int, size float) in class com.google.android.exoplayer2.text.Cue

Code Before:
------------
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
 import java.lang.annotation.Retention;
@@ -78,13 +79,19 @@ public class Cue {
    * The alignment of the cue text within the cue box, or null if the alignment is undefined.
    */
   public final Alignment textAlignment;
   /**
    * The position of the {@link #lineAnchor} of the cue box within the viewport in the direction
    * orthogonal to the writing direction, or {@link #DIMEN_UNSET}. When set, the interpretation of
    * the value depends on the value of {@link #lineType}.
    * <p>
    * For horizontal text and {@link #lineType} equal to {@link #LINE_TYPE_FRACTION}, this is the
    * fractional vertical position relative to the top of the viewport.
    */
   public final float line;
   /**
@@ -119,6 +126,8 @@ public class Cue {
    * For horizontal text, this is the horizontal position relative to the left of the viewport. Note
    * that positioning is relative to the left of the viewport even in the case of right-to-left
    * text.
    */
   public final float position;
   /**
@@ -134,9 +143,25 @@ public class Cue {
   /**
    * The size of the cue box in the writing direction specified as a fraction of the viewport size
    * in that direction, or {@link #DIMEN_UNSET}.
    */
   public final float size;
 
   /**
    * Constructs a cue whose {@link #textAlignment} is null, whose type parameters are set to
    * {@link #TYPE_UNSET} and whose dimension parameters are set to {@link #DIMEN_UNSET}.
@@ -159,6 +184,24 @@ public Cue(CharSequence text) {
    */
   public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
       @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size) {
     this.text = text;
     this.textAlignment = textAlignment;
     this.line = line;
@@ -167,6 +210,8 @@ public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int
     this.position = position;
     this.positionAnchor = positionAnchor;
     this.size = size;
   }
 
 }

Code After:
------------
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
+import android.graphics.Bitmap;
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
 import java.lang.annotation.Retention;
@@ -78,13 +79,19 @@ public class Cue {
    * The alignment of the cue text within the cue box, or null if the alignment is undefined.
    */
   public final Alignment textAlignment;
+  /**
+   * The cue image.
+   */
+  public final Bitmap bitmap;
   /**
    * The position of the {@link #lineAnchor} of the cue box within the viewport in the direction
    * orthogonal to the writing direction, or {@link #DIMEN_UNSET}. When set, the interpretation of
    * the value depends on the value of {@link #lineType}.
    * <p>
    * For horizontal text and {@link #lineType} equal to {@link #LINE_TYPE_FRACTION}, this is the
    * fractional vertical position relative to the top of the viewport.
+   * <p>
+   * If {@link #bitmap} is not null then this value is used to indicate the top position
    */
   public final float line;
   /**
@@ -119,6 +126,8 @@ public class Cue {
    * For horizontal text, this is the horizontal position relative to the left of the viewport. Note
    * that positioning is relative to the left of the viewport even in the case of right-to-left
    * text.
+   * <p>
+   * If {@link #bitmap} is not null then this value is used to indicate the left position
    */
   public final float position;
   /**
@@ -134,9 +143,25 @@ public class Cue {
   /**
    * The size of the cue box in the writing direction specified as a fraction of the viewport size
    * in that direction, or {@link #DIMEN_UNSET}.
+   * <p>
+   * If {@link #bitmap} is not null then this value is used to indicate the width
    */
   public final float size;
 
+  /**
+   * The height size of the cue box when a {@link #bitmap} is set specified as a fraction of the
+   * viewport size in that direction, or {@link #DIMEN_UNSET}.
+   */
+  public final float size_height;
+
+  /**
+   *
+   */
+  public Cue(Bitmap bitmap, float left, float top, float size, float size_height) {
+    this(null, null, top, LINE_TYPE_FRACTION, TYPE_UNSET, left, TYPE_UNSET, size, size_height,
+     bitmap);
+  }
+
   /**
    * Constructs a cue whose {@link #textAlignment} is null, whose type parameters are set to
    * {@link #TYPE_UNSET} and whose dimension parameters are set to {@link #DIMEN_UNSET}.
@@ -159,6 +184,24 @@ public Cue(CharSequence text) {
    */
   public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
       @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size) {
+    this(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, size,
+     DIMEN_UNSET, null);
+  }
+  /**
+   * @param text See {@link #text}.
+   * @param textAlignment See {@link #textAlignment}.
+   * @param line See {@link #line}.
+   * @param lineType See {@link #lineType}.
+   * @param lineAnchor See {@link #lineAnchor}.
+   * @param position See {@link #position}.
+   * @param positionAnchor See {@link #positionAnchor}.
+   * @param size See {@link #size}.
+   * @param size_height See {@link #size_height}.
+   * @param bitmap See {@link #bitmap}.
+   */
+  private Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
+    @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size,
+    float size_height, Bitmap bitmap) {
     this.text = text;
     this.textAlignment = textAlignment;
     this.line = line;
@@ -167,6 +210,8 @@ public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int
     this.position = position;
     this.positionAnchor = positionAnchor;
     this.size = size;
+    this.size_height = size_height;
+    this.bitmap = bitmap;
   }
 
 }

Example 3:

Refactoring Description: Extract Method private resolveConfigFile(fileName String, confFile File) : void extracted from public getByPath(configurationPath String) : Config in class org.tron.core.config.Configuration

Code Before:
------------
@@ -19,10 +19,15 @@
 package org.tron.core.config;
 
 import static org.apache.commons.lang3.StringUtils.isBlank;
 
 import com.typesafe.config.ConfigFactory;
 import java.io.File;
 import lombok.extern.slf4j.Slf4j;
 
 @Slf4j
 public class Configuration {
@@ -32,29 +37,36 @@ public class Configuration {
   /**
    * Get configuration by a given path.
    *
-   * @param configurationPath path to configuration file
    * @return loaded configuration
    */
-  public static com.typesafe.config.Config getByPath(final String configurationPath) {
-    if (isBlank(configurationPath)) {
-      throw new IllegalArgumentException("Configuration path is required!");
     }
 
-    File confFile = new File(configurationPath);
-    if (confFile.exists()) {
-      config = ConfigFactory.parseFile(new File(configurationPath));
     } else {
-      config = ConfigFactory.load(configurationPath);
     }
-    return config;
   }
 
-  public static com.typesafe.config.Config getByFile(final File confFile) {
-    if (!confFile.exists()) {
-      throw new IllegalArgumentException("Configuration path is required!");
     }
-    config = ConfigFactory.parseFile(confFile);
-    return config;
   }
 }
 

Code After:
------------
@@ -19,10 +19,15 @@
 package org.tron.core.config;
 
 import static org.apache.commons.lang3.StringUtils.isBlank;
+import static org.apache.commons.lang3.StringUtils.isNoneBlank;
 
 import com.typesafe.config.ConfigFactory;
+
 import java.io.File;
+import java.io.FileNotFoundException;
+
 import lombok.extern.slf4j.Slf4j;
+import org.springframework.util.ResourceUtils;
 
 @Slf4j
 public class Configuration {
@@ -32,29 +37,36 @@ public class Configuration {
   /**
    * Get configuration by a given path.
    *
+   * @param confFileName path to configuration file
    * @return loaded configuration
    */
+  public static com.typesafe.config.Config getByFileName(final String shellConfFileName, final String confFileName) {
+    if (isNoneBlank(shellConfFileName)) {
+      File shellConfFile = new File(shellConfFileName);
+      resolveConfigFile(shellConfFileName, shellConfFile);
+      return config;
     }
 
+    if (isBlank(confFileName)) {
+      throw new IllegalArgumentException("Configuration path is required!");
     } else {
+      File confFile = new File(confFileName);
+      resolveConfigFile(confFileName, confFile);
+      return config;
     }
   }
 
+  private static void resolveConfigFile(String fileName, File confFile) {
+    if (confFile.exists()) {
+      config = ConfigFactory.parseFile(confFile);
+    } else {
+      try {
+        ResourceUtils.getFile("classpath:" + fileName);
+      } catch (FileNotFoundException e) {
+        throw new IllegalArgumentException("Configuration path is required! No Such file " + fileName);
+      }
+      config = ConfigFactory.load(fileName);
     }
   }
 }
 

================= REFACTORING MECHANICS =================

Please provide a refactored version of the code snippets above using the Extract Method technique, following these mechanics: 

1. Find a piece of code that does one clear task.
2. Note what variables it uses or changes.
3. Create a new method with a clear name.
4. Move the piece there, adding needed parameters and returns.
5. Replace the old chunk with a call to the new method.
6. Compile and Test to confirm it works the same.

================= CODE TO REFACTOR =================

private void visitTagEliminateLock(Tag tagEliminateLock, IParseDictionary parseDictionary) {
    String kind = tagEliminateLock.getAttributes().get(ATTR_KIND);
    List<Tag> childrenJVMS = tagEliminateLock.getNamedChildren(TAG_JVMS);
    if (childrenJVMS.size() > 0) {
        for (Tag tagJVMS : childrenJVMS) {
            Map<String, String> tagJVMSAttributes = tagJVMS.getAttributes();
            String attrBCI = tagJVMSAttributes.get(ATTR_BCI);
            int bciValue = 0;
            if (attrBCI != null) {
                try {
                    bciValue = Integer.parseInt(attrBCI);
                } catch (NumberFormatException nfe) {
                    logger.error("Couldn't parse bci attribute {} tag {}", attrBCI, tagJVMS.toString(true));
                    continue;
                }
            } else {
                logger.error("Missing bci attribute on tag {}", tagJVMS.toString(true));
            }
            String methodID = tagJVMSAttributes.get(ATTR_METHOD);
            BCIOpcodeMap bciOpcodeMap = parseDictionary.getBCIOpcodeMap(methodID);
            //logger.info("current {} methodID {} parseMethod {}", currentMember.toStringUnqualifiedMethodName(true, true), methodID, parseDictionary.getParseMethod());
            if (CompilationUtil.memberMatchesMethodID(currentMember, methodID, parseDictionary)) {
                storeElidedLock(currentMember, bciValue, kind, bciOpcodeMap);
            } else if (processAnnotationsForInlinedMethods) {
                IMetaMember inlinedMember = findMemberForInlinedMethod(tagJVMS, parseDictionary);
                if (inlinedMember != null) {
                    storeElidedLock(inlinedMember, bciValue, kind, bciOpcodeMap);
                } else {
                    unhandledTags.add(tagJVMS);
                }
            }
        }
        // end for
    }
}

================= OUTPUT FORMAT =================


Return the result strictly using the format below:
<refactored code>
[The code after the refactoring should be between these tags.]
</refactored code>
<refactoring explanation>
[The explanation of the refactoring should be between these tags.]
</refactoring explanation>