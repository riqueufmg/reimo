You are an expert in refactoring code snippets. Here are some examples of refactoring using the Extract Method technique.

================= EXAMPLES =================

Example 1:

Refactoring Description: Extract Method private internalGet(key String, value Object, statement Statement) : LegacyIndexHits extracted from public get(key String, value Object) : IndexHits<T> in class org.neo4j.kernel.impl.coreapi.LegacyIndexProxy

Code Before:
------------
@@ -42,6 +42,10 @@
 
 import static java.lang.String.format;
 
 public class LegacyIndexProxy<T extends PropertyContainer> implements Index<T>
 {
     public interface Lookup
@@ -102,14 +106,6 @@ void drop( DataWriteOperations operations, String name )
             {
                 operations.nodeLegacyIndexDrop( name );
             }
-
-            @Override
-            long putIfAbsent( DataWriteOperations operations, long id, String key, Object value )
-                    throws EntityNotFoundException, InvalidTransactionTypeKernelException,
-                    ReadOnlyDatabaseKernelException
-            {
-                return operations.nodeLegacyIndexPutIfAbsent( id, key, value );
-            }
         },
         RELATIONSHIP
         {
@@ -160,14 +156,6 @@ void drop( DataWriteOperations operations, String name ) throws InvalidTransacti
             {
                 operations.relationshipLegacyIndexDrop( name );
             }
-
-            @Override
-            long putIfAbsent( DataWriteOperations operations, long id, String key, Object value )
-                    throws EntityNotFoundException, InvalidTransactionTypeKernelException,
-                    ReadOnlyDatabaseKernelException
-            {
-                return operations.relationshipLegacyIndexPutIfAbsent( id, key, value );
-            }
         }
 
         ;
@@ -190,9 +178,6 @@ abstract void remove( DataWriteOperations operations, String name, long id )
 
         abstract void drop( DataWriteOperations operations, String name )
                 throws InvalidTransactionTypeKernelException, ReadOnlyDatabaseKernelException;
-
-        abstract long putIfAbsent( DataWriteOperations operations, long id, String key, Object value )
-                throws EntityNotFoundException, InvalidTransactionTypeKernelException, ReadOnlyDatabaseKernelException;
     }
 
     private final String name;
@@ -226,14 +211,20 @@ public IndexHits<T> get( String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
-            return wrapIndexHits( statement.readOperations().nodeLegacyIndexGet( name, key, value ) );
         }
         catch ( LegacyIndexNotFoundKernelException e )
         {
             throw new NotFoundException( type + " index '" + name + "' doesn't exist" );
         }
     }
 
     private IndexHits<T> wrapIndexHits( final LegacyIndexHits ids )
     {
         return new IndexHits<T>()
@@ -344,7 +335,7 @@ public void add( T entity, String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
-            type.add( statement.dataWriteOperations(), name, entity.getId(), key, value );
         }
         catch ( EntityNotFoundException e )
         {
@@ -433,7 +424,27 @@ public T putIfAbsent( T entity, String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
-            return entityOf( type.putIfAbsent( statement.dataWriteOperations(), entity.getId(), key, value ) );
         }
         catch ( EntityNotFoundException e )
         {
@@ -447,5 +458,15 @@ public T putIfAbsent( T entity, String key, Object value )
         {
             throw new ReadOnlyDbException();
         }
     }
 }

Code After:
------------
@@ -42,6 +42,10 @@
 
 import static java.lang.String.format;
 
+import static org.neo4j.collection.primitive.PrimitiveLongCollections.single;
+import static org.neo4j.kernel.impl.locking.ResourceTypes.LEGACY_INDEX;
+import static org.neo4j.kernel.impl.locking.ResourceTypes.legacyIndexResourceId;
+
 public class LegacyIndexProxy<T extends PropertyContainer> implements Index<T>
 {
     public interface Lookup
@@ -102,14 +106,6 @@ void drop( DataWriteOperations operations, String name )
             {
                 operations.nodeLegacyIndexDrop( name );
             }
         },
         RELATIONSHIP
         {
@@ -160,14 +156,6 @@ void drop( DataWriteOperations operations, String name ) throws InvalidTransacti
             {
                 operations.relationshipLegacyIndexDrop( name );
             }
         }
 
         ;
@@ -190,9 +178,6 @@ abstract void remove( DataWriteOperations operations, String name, long id )
 
         abstract void drop( DataWriteOperations operations, String name )
                 throws InvalidTransactionTypeKernelException, ReadOnlyDatabaseKernelException;
     }
 
     private final String name;
@@ -226,14 +211,20 @@ public IndexHits<T> get( String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
+            return wrapIndexHits( internalGet( key, value, statement ) );
         }
         catch ( LegacyIndexNotFoundKernelException e )
         {
             throw new NotFoundException( type + " index '" + name + "' doesn't exist" );
         }
     }
 
+    private LegacyIndexHits internalGet( String key, Object value, Statement statement )
+            throws LegacyIndexNotFoundKernelException
+    {
+        return statement.readOperations().nodeLegacyIndexGet( name, key, value );
+    }
+
     private IndexHits<T> wrapIndexHits( final LegacyIndexHits ids )
     {
         return new IndexHits<T>()
@@ -344,7 +335,7 @@ public void add( T entity, String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
+            internalAdd( entity, key, value, statement );
         }
         catch ( EntityNotFoundException e )
         {
@@ -433,7 +424,27 @@ public T putIfAbsent( T entity, String key, Object value )
     {
         try ( Statement statement = statementContextBridge.instance() )
         {
+            // Does it already exist?
+            long existing = single( internalGet( key, value, statement ), -1L );
+            if ( existing != -1 )
+            {
+                return entityOf( existing );
+            }
+
+            // No, OK so Grab lock
+            statement.readOperations().acquireExclusive( LEGACY_INDEX, legacyIndexResourceId( name, key ) );
+            // and check again -- now holding an exclusive lock
+            existing = single( internalGet( key, value, statement ), -1L );
+            if ( existing != -1 )
+            {
+                // Someone else created this entry before us just before we got the lock,
+                // release the lock as we won't be needing it
+                statement.readOperations().releaseExclusive( LEGACY_INDEX, legacyIndexResourceId( name, key ) );
+                return entityOf( existing );
+            }
+
+            internalAdd( entity, key, value, statement );
+            return null;
         }
         catch ( EntityNotFoundException e )
         {
@@ -447,5 +458,15 @@ public T putIfAbsent( T entity, String key, Object value )
         {
             throw new ReadOnlyDbException();
         }
+        catch ( LegacyIndexNotFoundKernelException e )
+        {
+            throw new RuntimeException( e );
+        }
+    }
+
+    private void internalAdd( T entity, String key, Object value, Statement statement ) throws EntityNotFoundException,
+            InvalidTransactionTypeKernelException, ReadOnlyDatabaseKernelException
+    {
+        type.add( statement.dataWriteOperations(), name, entity.getId(), key, value );
     }
 }

Example 2:

Refactoring Description: Extract Method public KBPAnnotator(name String, props Properties) extracted from public KBPAnnotator(props Properties) in class edu.stanford.nlp.pipeline.KBPAnnotator

Code Before:
------------
@@ -61,7 +61,7 @@ public class KBPAnnotator implements Annotator {
    *
    * @param props The properties to use when creating this extractor.
    */
-  public KBPAnnotator(Properties props) {
     // Parse standard properties
     this.threads = Integer.parseInt(props.getProperty("threads", "1"));
 
@@ -92,6 +92,12 @@ public KBPAnnotator(Properties props) {
   }
 
 
   /**
    * Returns whether the given token counts as a valid pronominal mention for KBP.
    * @param word The token to classify.

Code After:
------------
@@ -61,7 +61,7 @@ public class KBPAnnotator implements Annotator {
    *
    * @param props The properties to use when creating this extractor.
    */
+  public KBPAnnotator(String name, Properties props) {
     // Parse standard properties
     this.threads = Integer.parseInt(props.getProperty("threads", "1"));
 
@@ -92,6 +92,12 @@ public KBPAnnotator(Properties props) {
   }
 
 
+  public KBPAnnotator(Properties properties) {
+    this(STANFORD_KBP, properties);
+
+  }
+
+
   /**
    * Returns whether the given token counts as a valid pronominal mention for KBP.
    * @param word The token to classify.

Example 3:

Refactoring Description: Extract Method private Cue(text CharSequence, textAlignment Alignment, line float, lineType int, lineAnchor int, position float, positionAnchor int, size float, size_height float, bitmap Bitmap) extracted from public Cue(text CharSequence, textAlignment Alignment, line float, lineType int, lineAnchor int, position float, positionAnchor int, size float) in class com.google.android.exoplayer2.text.Cue

Code Before:
------------
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
 import java.lang.annotation.Retention;
@@ -78,13 +79,19 @@ public class Cue {
    * The alignment of the cue text within the cue box, or null if the alignment is undefined.
    */
   public final Alignment textAlignment;
   /**
    * The position of the {@link #lineAnchor} of the cue box within the viewport in the direction
    * orthogonal to the writing direction, or {@link #DIMEN_UNSET}. When set, the interpretation of
    * the value depends on the value of {@link #lineType}.
    * <p>
    * For horizontal text and {@link #lineType} equal to {@link #LINE_TYPE_FRACTION}, this is the
    * fractional vertical position relative to the top of the viewport.
    */
   public final float line;
   /**
@@ -119,6 +126,8 @@ public class Cue {
    * For horizontal text, this is the horizontal position relative to the left of the viewport. Note
    * that positioning is relative to the left of the viewport even in the case of right-to-left
    * text.
    */
   public final float position;
   /**
@@ -134,9 +143,25 @@ public class Cue {
   /**
    * The size of the cue box in the writing direction specified as a fraction of the viewport size
    * in that direction, or {@link #DIMEN_UNSET}.
    */
   public final float size;
 
   /**
    * Constructs a cue whose {@link #textAlignment} is null, whose type parameters are set to
    * {@link #TYPE_UNSET} and whose dimension parameters are set to {@link #DIMEN_UNSET}.
@@ -159,6 +184,24 @@ public Cue(CharSequence text) {
    */
   public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
       @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size) {
     this.text = text;
     this.textAlignment = textAlignment;
     this.line = line;
@@ -167,6 +210,8 @@ public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int
     this.position = position;
     this.positionAnchor = positionAnchor;
     this.size = size;
   }
 
 }

Code After:
------------
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
+import android.graphics.Bitmap;
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
 import java.lang.annotation.Retention;
@@ -78,13 +79,19 @@ public class Cue {
    * The alignment of the cue text within the cue box, or null if the alignment is undefined.
    */
   public final Alignment textAlignment;
+  /**
+   * The cue image.
+   */
+  public final Bitmap bitmap;
   /**
    * The position of the {@link #lineAnchor} of the cue box within the viewport in the direction
    * orthogonal to the writing direction, or {@link #DIMEN_UNSET}. When set, the interpretation of
    * the value depends on the value of {@link #lineType}.
    * <p>
    * For horizontal text and {@link #lineType} equal to {@link #LINE_TYPE_FRACTION}, this is the
    * fractional vertical position relative to the top of the viewport.
+   * <p>
+   * If {@link #bitmap} is not null then this value is used to indicate the top position
    */
   public final float line;
   /**
@@ -119,6 +126,8 @@ public class Cue {
    * For horizontal text, this is the horizontal position relative to the left of the viewport. Note
    * that positioning is relative to the left of the viewport even in the case of right-to-left
    * text.
+   * <p>
+   * If {@link #bitmap} is not null then this value is used to indicate the left position
    */
   public final float position;
   /**
@@ -134,9 +143,25 @@ public class Cue {
   /**
    * The size of the cue box in the writing direction specified as a fraction of the viewport size
    * in that direction, or {@link #DIMEN_UNSET}.
+   * <p>
+   * If {@link #bitmap} is not null then this value is used to indicate the width
    */
   public final float size;
 
+  /**
+   * The height size of the cue box when a {@link #bitmap} is set specified as a fraction of the
+   * viewport size in that direction, or {@link #DIMEN_UNSET}.
+   */
+  public final float size_height;
+
+  /**
+   *
+   */
+  public Cue(Bitmap bitmap, float left, float top, float size, float size_height) {
+    this(null, null, top, LINE_TYPE_FRACTION, TYPE_UNSET, left, TYPE_UNSET, size, size_height,
+     bitmap);
+  }
+
   /**
    * Constructs a cue whose {@link #textAlignment} is null, whose type parameters are set to
    * {@link #TYPE_UNSET} and whose dimension parameters are set to {@link #DIMEN_UNSET}.
@@ -159,6 +184,24 @@ public Cue(CharSequence text) {
    */
   public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
       @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size) {
+    this(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, size,
+     DIMEN_UNSET, null);
+  }
+  /**
+   * @param text See {@link #text}.
+   * @param textAlignment See {@link #textAlignment}.
+   * @param line See {@link #line}.
+   * @param lineType See {@link #lineType}.
+   * @param lineAnchor See {@link #lineAnchor}.
+   * @param position See {@link #position}.
+   * @param positionAnchor See {@link #positionAnchor}.
+   * @param size See {@link #size}.
+   * @param size_height See {@link #size_height}.
+   * @param bitmap See {@link #bitmap}.
+   */
+  private Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
+    @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size,
+    float size_height, Bitmap bitmap) {
     this.text = text;
     this.textAlignment = textAlignment;
     this.line = line;
@@ -167,6 +210,8 @@ public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int
     this.position = position;
     this.positionAnchor = positionAnchor;
     this.size = size;
+    this.size_height = size_height;
+    this.bitmap = bitmap;
   }
 
 }

================= REFACTORING MECHANICS =================

Please provide a refactored version of the code snippets above using the Extract Method technique, following these mechanics: 

1. Find a piece of code that does one clear task.
2. Note what variables it uses or changes.
3. Create a new method with a clear name.
4. Move the piece there, adding needed parameters and returns.
5. Replace the old chunk with a call to the new method.
6. Compile and Test to confirm it works the same.

================= CODE TO REFACTOR =================

/**
 *     Run a depth-first filtered traversal of the root and all of its descendants.
 *     @param filter NodeFilter visitor.
 *     @param root the root node point to traverse.
 *     @return The filter result of the root node, or {@link FilterResult#STOP}.
 *
 *     @see NodeFilter
 */
public static FilterResult filter(NodeFilter filter, Node root) {
    Node node = root;
    int depth = 0;
    while (node != null) {
        FilterResult result = filter.head(node, depth);
        if (result == FilterResult.STOP)
            return result;
        // Descend into child nodes:
        if (result == FilterResult.CONTINUE && node.childNodeSize() > 0) {
            node = node.childNode(0);
            ++depth;
            continue;
        }
        // No siblings, move upwards:
        while (true) {
            // depth > 0, so has parent
            assert node != null;
            if (!(node.nextSibling() == null && depth > 0))
                break;
            // 'tail' current node:
            if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {
                result = filter.tail(node, depth);
                if (result == FilterResult.STOP)
                    return result;
            }
            // In case we need to remove it below.
            Node prev = node;
            node = node.parentNode();
            depth--;
            if (result == FilterResult.REMOVE)
                // Remove AFTER finding parent.
                prev.remove();
            // Parent was not pruned.
            result = FilterResult.CONTINUE;
        }
        // 'tail' current node, then proceed with siblings:
        if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {
            result = filter.tail(node, depth);
            if (result == FilterResult.STOP)
                return result;
        }
        if (node == root)
            return result;
        // In case we need to remove it below.
        Node prev = node;
        node = node.nextSibling();
        if (result == FilterResult.REMOVE)
            // Remove AFTER finding sibling.
            prev.remove();
    }
    // root == null?
    return FilterResult.CONTINUE;
}

================= OUTPUT FORMAT =================


Return the result strictly using the format below:
<refactored code>
[The code after the refactoring should be between these tags.]
</refactored code>
<refactoring explanation>
[The explanation of the refactoring should be between these tags.]
</refactoring explanation>