  <refactored code>

/**
 * Returns the number of characters between the current position and the next instance of the input sequence
 *
 * @param seq scan target
 * @return offset between current position and next instance of target. -1 if not found.
 */
int nextIndexOf(CharSequence seq) {
    return findNextIndexOf(seq, bufPos, bufLength);
}

private int findNextIndexOf(CharSequence seq, int start, int end) {
    bufferUp();
    // doesn't handle scanning for surrogates
    char startChar = seq.charAt(0);
    for (int offset = start; offset < end; offset++) {
        // scan to first instance of startchar:
        if (startChar != charBuf[offset])
            while (++offset < end && startChar != charBuf[offset]) {
                /* empty */
            }
        int i = offset + 1;
        int last = i + seq.length() - 1;
        if (offset < end && last <= end) {
            for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) {
                /* empty */
            }
            if (// found full sequence
            i == last)
                return offset - bufPos;
        }
    }
    return -1;
}

</refactored code>
<refactoring explanation>

The original method is too long and complex. It performs two tasks: it buffers up the input, and it scans for the next instance of a given sequence.

To make the code more readable and maintainable, we have extracted the buffering up logic into a separate method. This method takes the start and end positions of the buffer as parameters, and returns the offset of the next instance of the sequence.

The original method is now simplified to just call the new method and return the result.

</refactoring explanation>