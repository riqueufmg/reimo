  <refactored code>

/**
 * Returns the number of characters between the current position and the next instance of the input sequence
 *
 * @param seq scan target
 * @return offset between current position and next instance of target. -1 if not found.
 */
int nextIndexOf(CharSequence seq) {
    return findNextIndexOf(seq, bufPos, bufLength);
}

private int findNextIndexOf(CharSequence seq, int start, int end) {
    // doesn't handle scanning for surrogates
    char startChar = seq.charAt(0);
    for (int offset = start; offset < end; offset++) {
        // scan to first instance of startchar:
        if (startChar != charBuf[offset])
            while (++offset < end && startChar != charBuf[offset]) {
                /* empty */
            }
        int i = offset + 1;
        int last = i + seq.length() - 1;
        if (offset < end && last <= end) {
            for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) {
                /* empty */
            }
            if (// found full sequence
            i == last)
                return offset - bufPos;
        }
    }
    return -1;
}

</refactored code>
<refactoring explanation>

The original method is too long and complex, making it difficult to understand and maintain. To address this, we have refactored the method into smaller, more manageable pieces.

The first step was to extract a new method called `findNextIndexOf` that takes the sequence to scan, the starting position, and the ending position as parameters. This method is responsible for finding the next instance of the sequence within the given range.

The original method was then refactored into two smaller methods: `bufferUp` and `nextIndexOf`. The `bufferUp` method is responsible for filling the buffer with characters from the input stream, while the `nextIndexOf` method is responsible for finding the next instance of the sequence within the buffer.

The `nextIndexOf` method now calls the `findNextIndexOf` method with the appropriate parameters, making the code more readable and easier to maintain.

</refactoring explanation>